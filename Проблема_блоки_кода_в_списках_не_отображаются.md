# Проблема: Блоки кода внутри списков не отображаются в Word

## Описание проблемы

Блоки кода (```csharp ... ```), которые находятся внутри элементов списка, не отображаются в документе Word. Они пропускаются при обработке.

## Анализ кода

### 1. Обработка списков в `ProcessListItems()`

**Файл:** `Services/MarkdownToWordFormatter.cs`, строки 502-528

```csharp
foreach (var block in listItem)
{
    blockIndex++;
    string blockType = block?.GetType().Name ?? "null";
    System.Diagnostics.Debug.WriteLine($"[ProcessListItems] Элемент #{itemIndex}, блок #{blockIndex}: {blockType}");
    
    if (block is ParagraphBlock paragraph)
    {
        // Извлекаем форматированный текст элемента списка
        var itemFormattedText = ConvertInlineToWordFormattedText(paragraph.Inline);
        
        if (itemFormattedText != null && itemFormattedText.Runs.Count > 0)
        {
            itemContents.Add(itemFormattedText);
        }
    }
    else
    {
        System.Diagnostics.Debug.WriteLine($"[ProcessListItems] Элемент #{itemIndex}, блок #{blockIndex}: не ParagraphBlock, пропускаем");
        // ← ПРОБЛЕМА: Блоки кода (CodeBlock) попадают сюда и пропускаются!
    }
}
```

**Проблема:** Обрабатываются только блоки типа `ParagraphBlock`. Все остальные типы блоков (включая `CodeBlock`) пропускаются.

### 2. Структура `WordListItem`

**Файл:** `Services/IWordElement.cs`, строки 429-439

```csharp
public class WordListItem : IWordElement
{
    public string ElementType => "ListItem";
    public List<WordFormattedText> Contents { get; set; }  // ← ПРОБЛЕМА: Только WordFormattedText!
    public bool IsOrdered { get; set; }
}
```

**Проблема:** `Contents` имеет тип `List<WordFormattedText>`, а не `List<IWordElement>`. Это означает, что в элемент списка можно добавить только форматированный текст, но нельзя добавить блок кода (`WordCodeBlock`), который является `IWordElement`, но не `WordFormattedText`.

### 3. Обработка блоков кода в основном потоке

**Файл:** `Services/MarkdownToWordFormatter.cs`, строки 585-587

```csharp
else if (block is CodeBlock codeBlock)
{
    return ProcessCodeBlock(codeBlock);
}
```

**Что работает:** Блоки кода, которые находятся **на верхнем уровне** документа (не внутри списков), обрабатываются правильно через `ProcessCodeBlock()` и создают `WordCodeBlock`.

## Найденные проблемы

### Проблема #1: Блоки кода внутри списков пропускаются

В методе `ProcessListItems()` на строке 508 проверяется только `block is ParagraphBlock`. Если блок является `CodeBlock`, он попадает в блок `else` (строка 524) и пропускается с сообщением "не ParagraphBlock, пропускаем".

**Последствие:** Блоки кода внутри элементов списка не обрабатываются и не добавляются в документ Word.

### Проблема #2: Архитектурное ограничение `WordListItem`

`WordListItem` может содержать только `List<WordFormattedText>`, что не позволяет хранить блоки кода (`WordCodeBlock`), которые являются отдельными элементами `IWordElement`.

**Последствие:** Даже если бы блоки кода обрабатывались в `ProcessListItems()`, их нельзя было бы добавить в `itemContents`, так как `WordCodeBlock` не является `WordFormattedText`.

## Пример проблемы

В Markdown:
```markdown
1. **Добавить логирование:**
   ```csharp
   LogError("Ошибка");
   ```
```

**Что происходит:**
1. Markdig парсит это как `ListBlock` с одним `ListItemBlock`
2. Внутри `ListItemBlock` есть:
   - `ParagraphBlock` с текстом "**Добавить логирование:**"
   - `CodeBlock` с кодом "LogError(\"Ошибка\");"
3. В `ProcessListItems()`:
   - `ParagraphBlock` обрабатывается и добавляется в `itemContents`
   - `CodeBlock` пропускается (строка 526)
4. Создается `WordListItem` только с текстом "Добавить логирование:", без блока кода

## Решение (только для справки, код не изменяю)

### Решение 1: Обработка блоков кода в `ProcessListItems()`

Добавить обработку `CodeBlock` в метод `ProcessListItems()`:

```csharp
if (block is ParagraphBlock paragraph)
{
    // Обработка параграфа
}
else if (block is CodeBlock codeBlock)
{
    // Обработать блок кода
    var codeElement = ProcessCodeBlock(codeBlock);
    if (codeElement != null)
    {
        // Добавить блок кода как отдельный элемент
        // Но это требует изменения архитектуры WordListItem
    }
}
```

### Решение 2: Изменить архитектуру `WordListItem`

Изменить `WordListItem` для поддержки различных типов элементов:

```csharp
public class WordListItem : IWordElement
{
    public string ElementType => "ListItem";
    public List<IWordElement> Contents { get; set; }  // ← Изменить на IWordElement
    public bool IsOrdered { get; set; }
}
```

Затем в `ProcessListItems()` можно добавлять как `WordFormattedText`, так и `WordCodeBlock`:

```csharp
if (block is ParagraphBlock paragraph)
{
    var itemFormattedText = ConvertInlineToWordFormattedText(paragraph.Inline);
    if (itemFormattedText != null && itemFormattedText.Runs.Count > 0)
    {
        itemContents.Add(itemFormattedText);  // WordFormattedText является IWordElement
    }
}
else if (block is CodeBlock codeBlock)
{
    var codeElement = ProcessCodeBlock(codeBlock);
    if (codeElement != null)
    {
        itemContents.Add(codeElement);  // WordCodeBlock является IWordElement
    }
}
```

### Решение 3: Создавать отдельные элементы для блоков кода

Вместо добавления блоков кода в `WordListItem`, создавать их как отдельные элементы `WordCodeBlock` в основном потоке обработки. Но это требует изменения логики парсинга, чтобы различать блоки кода внутри списков и вне их.

## Вывод

**Главная проблема:** Блоки кода внутри элементов списка не обрабатываются в методе `ProcessListItems()`, так как там обрабатываются только `ParagraphBlock`.

**Дополнительная проблема:** Даже если бы блоки кода обрабатывались, их нельзя было бы добавить в `WordListItem`, так как `Contents` имеет тип `List<WordFormattedText>`, а не `List<IWordElement>`.

**Требуется:** 
1. Добавить обработку `CodeBlock` в `ProcessListItems()`
2. Изменить архитектуру `WordListItem` для поддержки различных типов элементов (`IWordElement` вместо только `WordFormattedText`)
3. Обновить метод `WordListItem.ApplyToWord()` для обработки различных типов элементов

