# Техническое задание: Исправление проблемы лишних пустых строк при конвертации Word → Markdown

## 1. Общая информация

**Дата создания:** 27.12.2025  
**Приоритет:** Высокий  
**Статус:** К выполнению  
**Основание:** Техническое заключение `Техническое_заключение_проблема_пустых_строк.md`

## 2. Цель и задачи

### 2.1. Цель
Устранить проблему появления лишних пустых строк в результирующем Markdown при конвертации документа Word в Markdown.

### 2.2. Задачи
1. Устранить лишние пустые строки перед блоками кода
2. Устранить пустые строки между элементами списка
3. Нормализовать количество пустых строк между элементами (1 вместо 2 где необходимо)
4. Устранить пустые строки в начале документа
5. Обеспечить корректную обработку блоков кода как первого элемента документа

## 3. Описание проблемы

### 3.1. Симптомы
При нажатии кнопки `btnConvert` (Word → Markdown) в результирующем Markdown появляются:
- **Две пустые строки** перед блоками кода
- **Пустые строки** между элементами списка (разрывают список)
- **Две пустые строки** между заголовками (вместо одной)
- **Две пустые строки** между параграфами (вместо одной)
- **Пустые строки** в начале документа

### 3.2. Корневая причина
Накопление переносов строк от разных источников:
1. Предыдущий элемент добавляет `\n` после себя
2. Логика `ConvertToMarkdown()` добавляет еще один `\n` перед блоком кода
3. `WordCodeBlock.ToMarkdown()` начинается с `\n` внутри себя

**Результат:** Три переноса строки подряд = две пустые строки перед блоком кода.

## 4. Места в коде для изменения

### 4.1. Основной файл
**Файл:** `Services/WordToMarkdownService.cs`  
**Метод:** `ConvertToMarkdown()`  
**Строки:** 83-182

### 4.2. Вспомогательный файл (для справки)
**Файл:** `Services/IWordElement.cs`  
**Метод:** `WordCodeBlock.ToMarkdown()`  
**Строки:** 1094-1122  
**Примечание:** Изменения не требуются, метод работает корректно

## 5. Детальный план исправления

### Задача 5.1: Исправить обработку блоков кода

**Проблема:** При обработке следующего элемента типа `WordCodeBlock` добавляется лишний перенос строки.

**Текущий код (строки 123-129):**
```csharp
// Если следующий элемент - блок кода, не добавляем лишние пустые строки
else if (nextElement is WordCodeBlock)
{
    // Блоки кода уже начинаются с переноса строки в ToMarkdown()
    // Достаточно одного переноса строки перед блоком кода
    sb.AppendLine();  // ← ПРОБЛЕМА: добавляет \n
}
```

**Решение:**
1. **Убрать** добавление переноса строки перед блоками кода
2. Блок кода сам начинается с переноса строки внутри себя (`\n` после ` ``` `)
3. Если предыдущий элемент уже добавил перенос строки, этого достаточно

**Новый код:**
```csharp
// Если следующий элемент - блок кода, не добавляем перенос строки
// Блок кода сам начинается с переноса строки внутри себя (после ```)
else if (nextElement is WordCodeBlock)
{
    // Не добавляем перенос строки - блок кода начнется с \n внутри себя
    // Предыдущий элемент уже добавил \n после себя (если это не первый элемент)
}
```

**Шаги реализации:**
1. Найти блок кода `else if (nextElement is WordCodeBlock)` (строка 124)
2. Удалить строку `sb.AppendLine();` (строка 128)
3. Обновить комментарий, объясняющий почему не добавляется перенос строки

### Задача 5.2: Добавить проверку первого элемента

**Проблема:** Если блок кода - первый элемент документа, перед ним не должно быть пустых строк, но текущий код не проверяет это.

**Решение:**
1. Добавить проверку, является ли элемент первым (`i == 0`)
2. Если элемент первый и это блок кода, не добавлять переносы строк перед ним
3. Если элемент первый и это не блок кода, также не добавлять переносы строк перед ним

**Новый код (добавить в начало цикла обработки элементов):**
```csharp
// Проходим по всем элементам и преобразуем их в Markdown
for (int i = 0; i < elements.Count; i++)
{
    var element = elements[i];
    if (element == null)
        continue;

    string markdown = element.ToMarkdown();
    
    if (!string.IsNullOrEmpty(markdown))
    {
        // Если это первый элемент и это блок кода, не добавляем переносы строк перед ним
        bool isFirstElement = (i == 0);
        
        sb.Append(markdown);
        
        // Добавляем переносы строк в зависимости от типа элемента и следующего элемента
        bool isLastElement = (i == elements.Count - 1);
        
        if (!isLastElement)
        {
            // Получаем следующий элемент для контекстной обработки
            var nextElement = elements[i + 1];
            
            // ... остальная логика
        }
    }
}
```

**Шаги реализации:**
1. Добавить переменную `bool isFirstElement = (i == 0);` после получения `markdown`
2. Использовать эту переменную при принятии решений о добавлении переносов строк

### Задача 5.3: Улучшить обработку элементов перед блоками кода

**Проблема:** Если перед блоком кода идет элемент (заголовок, параграф), он добавляет `\n` после себя, а затем логика добавляет еще один `\n` перед блоком кода.

**Решение:**
1. Если следующий элемент - `WordCodeBlock`, предыдущий элемент не должен добавлять перенос строки после себя
2. Или предыдущий элемент добавляет перенос строки, но логика не добавляет еще один перед блоком кода

**Новый код (изменить логику для всех элементов):**
```csharp
if (!isLastElement)
{
    var nextElement = elements[i + 1];
    
    // Если следующий элемент - блок кода, предыдущий элемент добавляет только один \n
    // Блок кода сам начнется с \n внутри себя
    if (nextElement is WordCodeBlock)
    {
        // Добавляем один перенос строки только если это не первый элемент
        // и если текущий элемент не заканчивается на перенос строки
        if (!isFirstElement)
        {
            // Проверяем, заканчивается ли markdown на перенос строки
            bool endsWithNewline = markdown.EndsWith("\n") || markdown.EndsWith("\r\n");
            if (!endsWithNewline)
            {
                sb.AppendLine();
            }
        }
    }
    // Остальная логика для других типов элементов
    else if (element is WordCodeBlock)
    {
        // Блоки кода уже заканчиваются переносом строки в ToMarkdown()
        // Добавляем одну пустую строку после блока кода
        sb.AppendLine();
    }
    // ... остальные условия
}
```

**Шаги реализации:**
1. Изменить условие `else if (nextElement is WordCodeBlock)` (строка 124)
2. Добавить проверку `!isFirstElement`
3. Добавить проверку, заканчивается ли `markdown` на перенос строки
4. Добавлять перенос строки только если элемент не заканчивается на перенос строки

### Задача 5.4: Добавить нормализацию результата

**Проблема:** Накопление переносов строк может создавать множественные пустые строки подряд.

**Решение:**
1. В конце метода `ConvertToMarkdown()` добавить нормализацию результата
2. Убрать множественные переносы строк подряд (более 2)
3. Убрать пустые строки в начале документа

**Новый код (добавить перед `return`):**
```csharp
string result = sb.ToString().TrimEnd();

// Нормализация: убираем множественные переносы строк подряд (более 2)
// Заменяем 3 и более переносов строк на 2
while (result.Contains("\n\n\n"))
{
    result = result.Replace("\n\n\n", "\n\n");
}

// Убираем пустые строки в начале документа
result = result.TrimStart('\n', '\r');

return result;
```

**Шаги реализации:**
1. Сохранить результат `sb.ToString().TrimEnd()` в переменную `result`
2. Добавить цикл для замены множественных переносов строк
3. Убрать пустые строки в начале с помощью `TrimStart`
4. Вернуть нормализованный результат

### Задача 5.5: Исправить обработку элементов списка

**Проблема:** Между элементами списка добавляется пустая строка, что разрывает список.

**Текущий код (строки 116-122):**
```csharp
// Элементы списка не должны иметь пустых строк между ними
if (element is WordListItem && nextElement is WordListItem)
{
    // Элементы списка идут подряд - не добавляем пустые строки
    // WordListItem.ToMarkdown() не добавляет перенос строки в конце
    sb.AppendLine();  // ← ПРОБЛЕМА: все равно добавляет \n
}
```

**Решение:**
1. Если следующий элемент - `WordListItem`, не добавлять перенос строки
2. `WordListItem.ToMarkdown()` не добавляет перенос строки в конце, поэтому элементы списка должны идти подряд

**Новый код:**
```csharp
// Элементы списка не должны иметь пустых строк между ними
if (element is WordListItem && nextElement is WordListItem)
{
    // Элементы списка идут подряд - не добавляем пустые строки
    // WordListItem.ToMarkdown() не добавляет перенос строки в конце
    // Просто переходим к следующему элементу без добавления \n
}
```

**Шаги реализации:**
1. Найти блок `if (element is WordListItem && nextElement is WordListItem)` (строка 117)
2. Удалить строку `sb.AppendLine();` (строка 121)
3. Обновить комментарий

## 6. Детальная спецификация изменений

### 6.1. Изменение 1: Убрать перенос строки перед блоками кода

**Файл:** `Services/WordToMarkdownService.cs`  
**Строки:** 123-129

**Было:**
```csharp
// Если следующий элемент - блок кода, не добавляем лишние пустые строки
else if (nextElement is WordCodeBlock)
{
    // Блоки кода уже начинаются с переноса строки в ToMarkdown()
    // Достаточно одного переноса строки перед блоком кода
    sb.AppendLine();
}
```

**Стало:**
```csharp
// Если следующий элемент - блок кода, не добавляем перенос строки
// Блок кода сам начинается с переноса строки внутри себя (после ```)
else if (nextElement is WordCodeBlock)
{
    // Не добавляем перенос строки - блок кода начнется с \n внутри себя
    // Предыдущий элемент уже добавил \n после себя (если это не первый элемент)
}
```

### 6.2. Изменение 2: Добавить проверку первого элемента

**Файл:** `Services/WordToMarkdownService.cs`  
**Строки:** 102-106

**Было:**
```csharp
string markdown = element.ToMarkdown();

if (!string.IsNullOrEmpty(markdown))
{
    sb.Append(markdown);
```

**Стало:**
```csharp
string markdown = element.ToMarkdown();

if (!string.IsNullOrEmpty(markdown))
{
    // Проверяем, является ли элемент первым в документе
    bool isFirstElement = (i == 0);
    
    sb.Append(markdown);
```

### 6.3. Изменение 3: Улучшить обработку элементов перед блоками кода

**Файл:** `Services/WordToMarkdownService.cs`  
**Строки:** 123-129

**Было:**
```csharp
else if (nextElement is WordCodeBlock)
{
    // Блоки кода уже начинаются с переноса строки в ToMarkdown()
    // Достаточно одного переноса строки перед блоком кода
    sb.AppendLine();
}
```

**Стало:**
```csharp
else if (nextElement is WordCodeBlock)
{
    // Если следующий элемент - блок кода, добавляем перенос строки только если:
    // 1. Это не первый элемент
    // 2. Текущий элемент не заканчивается на перенос строки
    if (!isFirstElement)
    {
        bool endsWithNewline = markdown.EndsWith("\n") || markdown.EndsWith("\r\n");
        if (!endsWithNewline)
        {
            sb.AppendLine();
        }
    }
}
```

### 6.4. Изменение 4: Добавить нормализацию результата

**Файл:** `Services/WordToMarkdownService.cs`  
**Строки:** 180-182

**Было:**
```csharp
return sb.ToString().TrimEnd();
```

**Стало:**
```csharp
string result = sb.ToString().TrimEnd();

// Нормализация: убираем множественные переносы строк подряд (более 2)
// Заменяем 3 и более переносов строк на 2
while (result.Contains("\n\n\n"))
{
    result = result.Replace("\n\n\n", "\n\n");
}

// Убираем пустые строки в начале документа
result = result.TrimStart('\n', '\r');

return result;
```

### 6.5. Изменение 5: Убрать перенос строки между элементами списка

**Файл:** `Services/WordToMarkdownService.cs`  
**Строки:** 116-122

**Было:**
```csharp
// Элементы списка не должны иметь пустых строк между ними
if (element is WordListItem && nextElement is WordListItem)
{
    // Элементы списка идут подряд - не добавляем пустые строки
    // WordListItem.ToMarkdown() не добавляет перенос строки в конце
    sb.AppendLine();
}
```

**Стало:**
```csharp
// Элементы списка не должны иметь пустых строк между ними
if (element is WordListItem && nextElement is WordListItem)
{
    // Элементы списка идут подряд - не добавляем пустые строки
    // WordListItem.ToMarkdown() не добавляет перенос строки в конце
    // Просто переходим к следующему элементу без добавления \n
}
```

## 7. Критерии приемки

### 7.1. Функциональные требования

1. **Блок кода после заголовка:**
   - **Было:** Две пустые строки между заголовком и блоком кода
   - **Должно быть:** Одна пустая строка между заголовком и блоком кода

2. **Блок кода как первый элемент:**
   - **Было:** Пустая строка перед блоком кода
   - **Должно быть:** Нет пустых строк перед блоком кода

3. **Элементы списка:**
   - **Было:** Пустые строки между элементами списка разрывают список
   - **Должно быть:** Элементы списка идут подряд без пустых строк

4. **Заголовки:**
   - **Было:** Две пустые строки между заголовками
   - **Должно быть:** Одна пустая строка между заголовками

5. **Параграфы:**
   - **Было:** Две пустые строки между параграфами
   - **Должно быть:** Одна пустая строка между параграфами

6. **Начало документа:**
   - **Было:** Пустые строки в начале документа
   - **Должно быть:** Нет пустых строк в начале документа

### 7.2. Тестовые сценарии

#### Тест 1: Блок кода после заголовка
**Исходный Word:**
```
# Заголовок
[блок кода]
```

**Ожидаемый Markdown:**
```markdown
# Заголовок

```
код
```
```

**Критерий:** Одна пустая строка между заголовком и блоком кода.

#### Тест 2: Блок кода как первый элемент
**Исходный Word:**
```
[блок кода]
```

**Ожидаемый Markdown:**
```markdown
```
код
```
```

**Критерий:** Нет пустых строк перед блоком кода.

#### Тест 3: Элементы списка
**Исходный Word:**
```
1. Первый элемент
2. Второй элемент
3. Третий элемент
```

**Ожидаемый Markdown:**
```markdown
1. Первый элемент
2. Второй элемент
3. Третий элемент
```

**Критерий:** Элементы списка идут подряд без пустых строк.

#### Тест 4: Заголовки
**Исходный Word:**
```
# Заголовок 1
## Заголовок 2
```

**Ожидаемый Markdown:**
```markdown
# Заголовок 1

## Заголовок 2
```

**Критерий:** Одна пустая строка между заголовками.

#### Тест 5: Параграфы
**Исходный Word:**
```
Первый параграф.
Второй параграф.
```

**Ожидаемый Markdown:**
```markdown
Первый параграф.

Второй параграф.
```

**Критерий:** Одна пустая строка между параграфами.

#### Тест 6: Начало документа
**Исходный Word:**
```
# Заголовок
```

**Ожидаемый Markdown:**
```markdown
# Заголовок
```

**Критерий:** Нет пустых строк в начале документа.

## 8. Порядок выполнения работ

### Этап 1: Подготовка (15 минут)
1. Создать резервную копию файла `Services/WordToMarkdownService.cs`
2. Изучить текущий код метода `ConvertToMarkdown()`
3. Подготовить тестовые документы Word для проверки

### Этап 2: Реализация изменений (60 минут)
1. **Изменение 1:** Убрать перенос строки перед блоками кода (строки 123-129)
2. **Изменение 2:** Добавить проверку первого элемента (после строки 102)
3. **Изменение 3:** Улучшить обработку элементов перед блоками кода (строки 123-129)
4. **Изменение 4:** Добавить нормализацию результата (строки 180-182)
5. **Изменение 5:** Убрать перенос строки между элементами списка (строки 116-122)

### Этап 3: Тестирование (45 минут)
1. Запустить приложение
2. Выполнить все тестовые сценарии (Тест 1-6)
3. Проверить результат в каждом сценарии
4. Исправить найденные ошибки

### Этап 4: Проверка и документирование (30 минут)
1. Проверить, что все критерии приемки выполнены
2. Обновить комментарии в коде
3. Задокументировать изменения

## 9. Риски и ограничения

### 9.1. Риски
1. **Изменение логики может повлиять на другие части кода:**
   - **Митигация:** Тщательное тестирование всех сценариев
   
2. **Нормализация может убрать нужные пустые строки:**
   - **Митигация:** Нормализация применяется только к множественным переносам (3+), оставляя двойные переносы

3. **Проверка первого элемента может не работать для всех случаев:**
   - **Митигация:** Добавить дополнительные проверки при необходимости

### 9.2. Ограничения
1. Изменения затрагивают только метод `ConvertToMarkdown()`
2. Не изменяется логика методов `ToMarkdown()` в классах элементов
3. Не изменяется логика извлечения элементов из Word документа

## 10. Дополнительные замечания

1. **Комментарии в коде:** Все изменения должны быть задокументированы комментариями, объясняющими логику

2. **Производительность:** Нормализация результата использует цикл `while`, который может быть медленным для больших документов. Если производительность станет проблемой, можно оптимизировать с помощью регулярных выражений.

3. **Обратная совместимость:** Изменения не должны нарушать существующую функциональность, только исправлять проблему с пустыми строками.

4. **Тестирование:** Рекомендуется протестировать на различных типах документов:
   - Документы только с текстом
   - Документы с блоками кода
   - Документы со списками
   - Документы с таблицами
   - Смешанные документы

## 11. Контрольный список выполнения

- [ ] Создана резервная копия файла `Services/WordToMarkdownService.cs`
- [ ] Выполнено изменение 1: Убрать перенос строки перед блоками кода
- [ ] Выполнено изменение 2: Добавить проверку первого элемента
- [ ] Выполнено изменение 3: Улучшить обработку элементов перед блоками кода
- [ ] Выполнено изменение 4: Добавить нормализацию результата
- [ ] Выполнено изменение 5: Убрать перенос строки между элементами списка
- [ ] Выполнен тест 1: Блок кода после заголовка
- [ ] Выполнен тест 2: Блок кода как первый элемент
- [ ] Выполнен тест 3: Элементы списка
- [ ] Выполнен тест 4: Заголовки
- [ ] Выполнен тест 5: Параграфы
- [ ] Выполнен тест 6: Начало документа
- [ ] Обновлены комментарии в коде
- [ ] Код проверен на ошибки компиляции
- [ ] Все критерии приемки выполнены

## 12. Контакты и ответственные

**Разработчик:** [Указать имя]  
**Тестировщик:** [Указать имя]  
**Ревьюер кода:** [Указать имя]

---

**Дата создания ТЗ:** 27.12.2025  
**Версия:** 1.0  
**Статус:** Готово к выполнению

