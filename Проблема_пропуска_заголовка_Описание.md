# Проблема: Заголовок "## Описание" пропускается и не отображается в Word

## Описание проблемы

Заголовок "## Описание" создавался и применялся к документу, но не отображался в Word. Из логов отладки видно:

```
[WordTitle.ApplyToWord] textRange создан: Start=2, End=29, Text='Модуль DocumentSyncService
'
```

Это означает, что `textRange` содержал текст **предыдущего** заголовка ("Модуль DocumentSyncService"), а не текущего ("Описание").

## Причина проблемы

В методе `WordTitle.ApplyToWord()` на строке **865** использовался:

```csharp
textRange = paragraph.Range;
```

Проблема в том, что:

1. **Создается новый параграф** через `doc.Content.Paragraphs.Add()`
2. **Вызывается `Content.ApplyToWord(doc, paragraph.Range)`** - это вставляет текст в параграф
3. **После вставки `paragraph.Range`** может включать весь контент параграфа, включая предыдущий текст из документа

Когда создается новый параграф через `Paragraphs.Add()`, Word может включить в его Range часть предыдущего контента документа, особенно если документ был недавно очищен.

## Решение

Исправление включает три ключевых изменения:

### 1. Очистка параграфа перед вставкой текста

```csharp
// КРИТИЧЕСКИ ВАЖНО: Очищаем параграф перед вставкой текста
// Это гарантирует, что параграф пустой и не содержит предыдущего контента
paragraph.Range.Text = "";
```

Это аналогично тому, как это делается в `WordParagraph.ApplyToWord()` на строке 622.

### 2. Запоминание начальной позиции

```csharp
// Запоминаем начальную позицию для создания Range только вставленного текста
int startPosition = paragraph.Range.Start;
```

### 3. Создание Range только для вставленного текста

```csharp
// Создаем Range только для вставленного текста (от начальной позиции до текущей позиции range)
// Исключаем символ конца параграфа (\r), если он есть
int endPosition = paragraph.Range.End;
if (endPosition > startPosition)
{
    // Проверяем, есть ли символ конца параграфа
    Range checkRange = doc.Range(endPosition - 1, endPosition);
    if (checkRange.Text == "\r" || checkRange.Text == "\a")
    {
        endPosition--; // Исключаем символ конца параграфа
    }
}

textRange = doc.Range(startPosition, endPosition);
```

Теперь `textRange` содержит **только** вставленный текст заголовка, а не весь контент параграфа.

## Исправленный код

```csharp
if (Content != null && Content.Runs.Count > 0)
{
    string headingText = string.Join("", Content.Runs.Select(r => r?.Text ?? ""));
    System.Diagnostics.Debug.WriteLine($"[WordTitle.ApplyToWord] Применение форматированного текста: '{headingText}'");

    // КРИТИЧЕСКИ ВАЖНО: Очищаем параграф перед вставкой текста
    // Это гарантирует, что параграф пустой и не содержит предыдущего контента
    paragraph.Range.Text = "";
    
    // Запоминаем начальную позицию для создания Range только вставленного текста
    int startPosition = paragraph.Range.Start;
    
    // Вставляем текст
    Content.ApplyToWord(doc, paragraph.Range);

    // Создаем Range только для вставленного текста (от начальной позиции до текущей позиции range)
    // Исключаем символ конца параграфа (\r), если он есть
    int endPosition = paragraph.Range.End;
    if (endPosition > startPosition)
    {
        // Проверяем, есть ли символ конца параграфа
        Range checkRange = doc.Range(endPosition - 1, endPosition);
        if (checkRange.Text == "\r" || checkRange.Text == "\a")
        {
            endPosition--; // Исключаем символ конца параграфа
        }
    }
    
    textRange = doc.Range(startPosition, endPosition);
    System.Diagnostics.Debug.WriteLine($"[WordTitle.ApplyToWord] textRange создан: Start={textRange.Start}, End={textRange.End}, Text='{textRange.Text}'");
}
```

## Результат

После исправления:

1. ✅ Параграф очищается перед вставкой текста
2. ✅ Запоминается начальная позиция вставки
3. ✅ Создается Range только для вставленного текста
4. ✅ Символ конца параграфа исключается из Range
5. ✅ Стиль и форматирование применяются только к вставленному тексту

Теперь заголовок "## Описание" будет правильно отображаться в Word документе.

## Аналогичная проблема в других местах

Эта же проблема может возникать в других методах, которые используют `paragraph.Range` после вставки текста. Рекомендуется применять тот же подход:

1. Очищать параграф перед вставкой
2. Запоминать начальную позицию
3. Создавать Range только для вставленного текста

