# Пошаговая инструкция: Исправление проблемы с блоками кода в списках

## Цель

Исправить проблему, когда блоки кода (```csharp ... ```) внутри элементов списка не отображаются в документе Word.

## Что нужно изменить

### Шаг 1: Изменить тип `Contents` в классе `WordListItem`

**Файл:** `Services/IWordElement.cs`  
**Строка:** 432

**Было:**
```csharp
public List<WordFormattedText> Contents { get; set; }
```

**Должно быть:**
```csharp
public List<IWordElement> Contents { get; set; }
```

**Также изменить конструктор (строка 435):**
```csharp
// Было:
public WordListItem(List<WordFormattedText> contents, bool isOrdered)

// Должно быть:
public WordListItem(List<IWordElement> contents, bool isOrdered)
```

---

### Шаг 2: Обновить метод `ToMarkdown()` в классе `WordListItem`

**Файл:** `Services/IWordElement.cs`  
**Строки:** 441-460

**Было:**
```csharp
public string ToMarkdown()
{
    if (Contents == null || Contents.Count == 0)
        return "";

    var sb = new StringBuilder();
    foreach (var content in Contents)
    {
        if (content != null)
        {
            string markdown = content.ToMarkdown();  // ← WordFormattedText.ToMarkdown()
            if (!string.IsNullOrEmpty(markdown))
            {
                sb.Append(markdown);
            }
        }
    }

    return sb.ToString();
}
```

**Должно быть:**
```csharp
public string ToMarkdown()
{
    if (Contents == null || Contents.Count == 0)
        return "";

    var sb = new StringBuilder();
    foreach (var content in Contents)
    {
        if (content != null)
        {
            // Теперь content может быть любым IWordElement
            string markdown = content.ToMarkdown();  // ← IWordElement.ToMarkdown()
            if (!string.IsNullOrEmpty(markdown))
            {
                sb.Append(markdown);
                // Добавляем перенос строки между элементами
                if (content is WordCodeBlock)
                {
                    sb.AppendLine();  // Блоки кода уже содержат переносы строк
                }
            }
        }
    }

    return sb.ToString();
}
```

**Примечание:** Метод `ToMarkdown()` уже должен работать, так как `IWordElement` имеет метод `ToMarkdown()`. Но можно добавить переносы строк для лучшего форматирования.

---

### Шаг 3: Обновить метод `ApplyToWord()` в классе `WordListItem`

**Файл:** `Services/IWordElement.cs`  
**Строки:** 461-535

**Было:**
```csharp
public void ApplyToWord(Document doc)
{
    // ...
    foreach (var content in Contents)
    {
        // Обрабатываем только WordFormattedText
        content.ApplyToWord(doc, listParagraph.Range);
        // ...
    }
}
```

**Должно быть:**
```csharp
public void ApplyToWord(Document doc)
{
    System.Diagnostics.Debug.WriteLine($"[WordListItem.ApplyToWord] НАЧАЛО: Contents.Count={Contents?.Count ?? 0}, IsOrdered={IsOrdered}");
    
    if (doc == null || Contents == null || Contents.Count == 0)
    {
        System.Diagnostics.Debug.WriteLine("[WordListItem.ApplyToWord] ВЫХОД: doc или Contents null или пусто");
        return;
    }

    // Обрабатываем каждый элемент внутри элемента списка
    int contentIndex = 0;
    foreach (var content in Contents)
    {
        contentIndex++;
        System.Diagnostics.Debug.WriteLine($"[WordListItem.ApplyToWord] Обработка content #{contentIndex}/{Contents.Count}, тип: {content?.GetType().Name ?? "null"}");
        
        if (content == null)
        {
            System.Diagnostics.Debug.WriteLine($"[WordListItem.ApplyToWord] ВНИМАНИЕ: content #{contentIndex} равен null, пропускаем");
            continue;
        }

        // Проверяем тип элемента
        if (content is WordFormattedText formattedText)
        {
            // Обработка форматированного текста (как было раньше)
            // 1. Создаем параграф для элемента списка
            var listParagraph = doc.Content.Paragraphs.Add();
            listParagraph.Range.Text = "";
            int paragraphStart = listParagraph.Range.Start;
            System.Diagnostics.Debug.WriteLine($"[WordListItem.ApplyToWord] Параграф создан, Start={paragraphStart}");
         
            // 2. Применяем форматированный текст
            formattedText.ApplyToWord(doc, listParagraph.Range);
            
            // Проверяем, что текст был вставлен
            int paragraphEndAfterInsert = listParagraph.Range.End;
            string paragraphTextAfterInsert = listParagraph.Range.Text ?? "";
            System.Diagnostics.Debug.WriteLine($"[WordListItem.ApplyToWord] После вставки текста: End={paragraphEndAfterInsert}, Text='{paragraphTextAfterInsert}' (длина: {paragraphTextAfterInsert.Length})");

            // 3. Применяем форматирование списка
            if (IsOrdered)
            {
                System.Diagnostics.Debug.WriteLine($"[WordListItem.ApplyToWord] Применение нумерованного списка");
                listParagraph.Range.ListFormat.ApplyNumberDefault();
            }
            else
            {
                System.Diagnostics.Debug.WriteLine($"[WordListItem.ApplyToWord] Применение маркированного списка");
                listParagraph.Range.ListFormat.ApplyBulletDefault();
            }

            // 4. Добавляем перенос строки
            System.Diagnostics.Debug.WriteLine($"[WordListItem.ApplyToWord] Вызов InsertParagraphAfter()");
            listParagraph.Range.InsertParagraphAfter();
            
            // Получаем последний параграф (который был создан через InsertParagraphAfter)
            var lastParagraphIndex = doc.Content.Paragraphs.Count;
            System.Diagnostics.Debug.WriteLine($"[WordListItem.ApplyToWord] После InsertParagraphAfter: lastParagraphIndex={lastParagraphIndex}");
            
            if (lastParagraphIndex > 0)
            {
                var newParagraph = doc.Content.Paragraphs[lastParagraphIndex];
                string newParagraphText = newParagraph.Range.Text ?? "";
                System.Diagnostics.Debug.WriteLine($"[WordListItem.ApplyToWord] Новый параграф (после InsertParagraphAfter): Text='{newParagraphText}' (длина: {newParagraphText.Length})");
                newParagraph.Range.ListFormat.RemoveNumbers();
                System.Diagnostics.Debug.WriteLine($"[WordListItem.ApplyToWord] Форматирование списка удалено из нового параграфа");
            }
        }
        else if (content is WordCodeBlock codeBlock)
        {
            // Обработка блока кода
            System.Diagnostics.Debug.WriteLine($"[WordListItem.ApplyToWord] Обработка блока кода");
            
            // Блок кода применяется БЕЗ форматирования списка
            // (блоки кода не должны быть частью списка)
            codeBlock.ApplyToWord(doc);
            
            System.Diagnostics.Debug.WriteLine($"[WordListItem.ApplyToWord] Блок кода применен");
        }
        else
        {
            // Обработка других типов элементов (если понадобится в будущем)
            System.Diagnostics.Debug.WriteLine($"[WordListItem.ApplyToWord] Обработка элемента типа: {content.GetType().Name}");
            content.ApplyToWord(doc);
        }
    }
    
    System.Diagnostics.Debug.WriteLine($"[WordListItem.ApplyToWord] ЗАВЕРШЕНО: обработано {contentIndex} элементов");
}
```

**Ключевые изменения:**
- Добавлена проверка типа элемента: `if (content is WordFormattedText formattedText)`
- Добавлена обработка блоков кода: `else if (content is WordCodeBlock codeBlock)`
- Блоки кода применяются без форматирования списка (они не должны быть частью списка)

---

### Шаг 4: Добавить обработку `CodeBlock` в метод `ProcessListItems()`

**Файл:** `Services/MarkdownToWordFormatter.cs`  
**Строки:** 498-528

**Было:**
```csharp
// Обрабатываем параграфы внутри элемента списка
var itemContents = new List<WordFormattedText>();  // ← Изменить тип!

foreach (var block in listItem)
{
    if (block is ParagraphBlock paragraph)
    {
        // Обработка параграфа
        var itemFormattedText = ConvertInlineToWordFormattedText(paragraph.Inline);
        if (itemFormattedText != null && itemFormattedText.Runs.Count > 0)
        {
            itemContents.Add(itemFormattedText);
        }
    }
    else
    {
        // Блоки кода пропускаются!
        System.Diagnostics.Debug.WriteLine("не ParagraphBlock, пропускаем");
    }
}
```

**Должно быть:**
```csharp
// Обрабатываем элементы внутри элемента списка (параграфы и блоки кода)
var itemContents = new List<IWordElement>();  // ← Изменить тип на IWordElement!

foreach (var block in listItem)
{
    if (block is ParagraphBlock paragraph)
    {
        // Обработка параграфа
        var itemFormattedText = ConvertInlineToWordFormattedText(paragraph.Inline);
        if (itemFormattedText != null && itemFormattedText.Runs.Count > 0)
        {
            itemContents.Add(itemFormattedText);  // WordFormattedText является IWordElement
            string itemText = string.Join("", itemFormattedText.Runs.Select(r => r?.Text ?? ""));
            System.Diagnostics.Debug.WriteLine($"[ProcessListItems] Элемент #{itemIndex}, блок #{blockIndex}: добавлен текст, Runs.Count={itemFormattedText.Runs.Count}, Text='{itemText}' (длина: {itemText.Length})");
        }
        else
        {
            System.Diagnostics.Debug.WriteLine($"[ProcessListItems] ВНИМАНИЕ: Элемент #{itemIndex}, блок #{blockIndex}: itemFormattedText null или Runs.Count=0");
        }
    }
    else if (block is CodeBlock codeBlock)
    {
        // Обработка блока кода
        System.Diagnostics.Debug.WriteLine($"[ProcessListItems] Элемент #{itemIndex}, блок #{blockIndex}: найден CodeBlock");
        var codeElement = ProcessCodeBlock(codeBlock);
        if (codeElement != null)
        {
            itemContents.Add(codeElement);  // WordCodeBlock является IWordElement
            System.Diagnostics.Debug.WriteLine($"[ProcessListItems] Элемент #{itemIndex}, блок #{blockIndex}: блок кода добавлен");
        }
        else
        {
            System.Diagnostics.Debug.WriteLine($"[ProcessListItems] ВНИМАНИЕ: Элемент #{itemIndex}, блок #{blockIndex}: ProcessCodeBlock вернул null");
        }
    }
    else
    {
        System.Diagnostics.Debug.WriteLine($"[ProcessListItems] Элемент #{itemIndex}, блок #{blockIndex}: не ParagraphBlock и не CodeBlock, пропускаем");
    }
}
```

**Ключевые изменения:**
- Изменить тип `itemContents` с `List<WordFormattedText>` на `List<IWordElement>` (строка 499)
- Добавить обработку `CodeBlock`: `else if (block is CodeBlock codeBlock)` (после строки 523)
- Вызвать `ProcessCodeBlock(codeBlock)` для создания `WordCodeBlock`
- Добавить созданный `WordCodeBlock` в `itemContents`

---

## Итоговая последовательность изменений

1. ✅ **Изменить тип `Contents`** в `WordListItem` (строка 432 в `IWordElement.cs`)
2. ✅ **Изменить конструктор** `WordListItem` (строка 435 в `IWordElement.cs`)
3. ✅ **Обновить `ToMarkdown()`** в `WordListItem` (опционально, строки 441-460 в `IWordElement.cs`)
4. ✅ **Обновить `ApplyToWord()`** в `WordListItem` (строки 461-535 в `IWordElement.cs`)
5. ✅ **Изменить тип `itemContents`** в `ProcessListItems()` (строка 499 в `MarkdownToWordFormatter.cs`)
6. ✅ **Добавить обработку `CodeBlock`** в `ProcessListItems()` (после строки 523 в `MarkdownToWordFormatter.cs`)

## Проверка после изменений

После внесения изменений проверьте:

1. Блоки кода внутри списков должны отображаться в Word
2. Блоки кода должны иметь правильное форматирование (моноширинный шрифт, фон и т.д.)
3. Блоки кода не должны иметь маркеры списка (они не являются частью списка)
4. Обычные элементы списка (текст) должны работать как раньше

## Важные замечания

- **Блоки кода не должны иметь форматирование списка** - они применяются как отдельные элементы, не являющиеся частью списка
- **Порядок элементов важен** - сначала текст элемента списка (с маркером), затем блок кода (без маркера)
- **Отладочные сообщения** помогут отследить, правильно ли обрабатываются блоки кода

