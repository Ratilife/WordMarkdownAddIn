# Техническое задание: Нормализация кода перед вставкой в Word

## 1. Общая информация

### 1.1. Название задачи
Реализация нормализации кода перед вставкой в Word для предотвращения появления пустых строк в Markdown-представлении блоков кода.

### 1.2. Цель
Устранить проблему появления лишних пустых строк в блоках кода при конвертации Word → Markdown путем удаления пустых строк из кода перед вставкой в Word.

### 1.3. Проблема
При вставке многострочного кода в Word через `InsertAfter(Code)` Word автоматически разбивает текст на параграфы по символам `\n` или `\r\n`. Пустые строки в исходном коде становятся пустыми параграфами в Word, которые затем появляются в Markdown-представлении как лишние пустые строки.

### 1.4. Решение
Нормализовать код перед вставкой в Word, удаляя все пустые строки. Это предотвратит создание пустых параграфов в Word и решит проблему на корневом уровне.

## 2. Требования

### 2.1. Функциональные требования

#### ФР-1: Удаление пустых строк
- Система должна удалять все пустые строки из кода перед вставкой в Word
- Пустой строкой считается строка, содержащая только пробелы, табуляции, переносы строк или их комбинации
- Пустая строка определяется методом `string.IsNullOrWhiteSpace()`

#### ФР-2: Сохранение структуры кода
- После удаления пустых строк структура кода должна сохраняться
- Порядок непустых строк должен оставаться неизменным
- Отступы в начале строк должны сохраняться

#### ФР-3: Обработка различных форматов переносов строк
- Система должна корректно обрабатывать:
  - Windows-формат: `\r\n`
  - Unix-формат: `\n`
  - Mac-формат: `\r`
  - Смешанные форматы

#### ФР-4: Обратная совместимость
- Изменения не должны влиять на существующий функционал
- Блоки кода без пустых строк должны работать как раньше
- Форматирование кода (шрифт, фон, отступы) должно применяться корректно

### 2.2. Нефункциональные требования

#### НФР-1: Производительность
- Нормализация кода не должна заметно влиять на производительность
- Обработка кода длиной до 10,000 строк должна выполняться менее чем за 100 мс

#### НФР-2: Надежность
- Система должна корректно обрабатывать:
  - Пустой код (`null` или `string.Empty`)
  - Код, состоящий только из пустых строк
  - Код с очень длинными строками
  - Код с нестандартными символами

#### НФР-3: Поддерживаемость
- Код должен быть понятным и документированным
- Должны быть добавлены комментарии, объясняющие логику нормализации

## 3. Местоположение изменений

### 3.1. Основной файл
**Файл:** `Services/IWordElement.cs`  
**Класс:** `WordCodeBlock`  
**Метод:** `ApplyToWord(Document doc)`  
**Строки:** 1208-1264

### 3.2. Точка изменения
Нормализация должна выполняться **перед** вызовом `InsertAfter(Code)` на строке 1215.

## 4. Детальная спецификация

### 4.1. Алгоритм нормализации

```
1. Проверить, что Code не пустой
   ЕСЛИ Code == null ИЛИ Code == string.Empty
       ВЕРНУТЬ (ничего не делать)

2. Разбить код на строки
   lines = Code.Split(new[] { "\r\n", "\n", "\r" }, StringSplitOptions.None)

3. Отфильтровать пустые строки
   nonEmptyLines = lines.Where(line => !string.IsNullOrWhiteSpace(line))

4. Объединить обратно в одну строку
   normalizedCode = string.Join("\n", nonEmptyLines)

5. Использовать normalizedCode вместо Code при вставке
   insertRange.InsertAfter(normalizedCode)
```

### 4.2. Псевдокод реализации

```csharp
public void ApplyToWord(Document doc)
{
    if (doc == null || string.IsNullOrEmpty(Code))
        return;

    try
    {
        // 1. НОРМАЛИЗАЦИЯ КОДА: Удаляем все пустые строки
        string normalizedCode = NormalizeCode(Code);
        
        if (string.IsNullOrEmpty(normalizedCode))
            return;

        // 2. Сохраняем начальную позицию
        int startPos = doc.Content.End - 1;

        // 3. Вставляем нормализованный код
        var insertRange = doc.Range(startPos);
        insertRange.InsertAfter(normalizedCode);  // ← Используем normalizedCode вместо Code

        // 4. Остальной код без изменений...
        // (применение форматирования, подсветка синтаксиса и т.д.)
    }
    catch (Exception ex)
    {
        System.Diagnostics.Debug.WriteLine($"Ошибка при вставке блока кода: {ex.Message}");
    }
}

/// <summary>
/// Нормализует код, удаляя все пустые строки
/// </summary>
private string NormalizeCode(string code)
{
    if (string.IsNullOrEmpty(code))
        return code;

    // Разбиваем код на строки
    var lines = code.Split(new[] { "\r\n", "\n", "\r" }, StringSplitOptions.None);

    // Удаляем все пустые строки
    var nonEmptyLines = lines.Where(line => !string.IsNullOrWhiteSpace(line));

    // Объединяем обратно в одну строку
    return string.Join("\n", nonEmptyLines);
}
```

## 5. План реализации

### Этап 1: Добавление метода нормализации
1. Добавить приватный метод `NormalizeCode(string code)` в класс `WordCodeBlock`
2. Реализовать логику удаления пустых строк
3. Добавить XML-документацию к методу

### Этап 2: Интеграция нормализации
1. Изменить метод `ApplyToWord` для использования нормализованного кода
2. Вызвать `NormalizeCode(Code)` перед вставкой
3. Использовать результат вместо исходного `Code`

### Этап 3: Тестирование
1. Протестировать с кодом без пустых строк
2. Протестировать с кодом с пустыми строками
3. Протестировать с пустым кодом
4. Протестировать с кодом, состоящим только из пустых строк
5. Протестировать с различными форматами переносов строк

### Этап 4: Проверка обратной совместимости
1. Убедиться, что существующие блоки кода работают корректно
2. Проверить, что форматирование применяется правильно
3. Проверить, что подсветка синтаксиса работает

## 6. Тестовые случаи

### ТС-1: Код без пустых строк
**Входные данные:**
```
Документ Word
├── Content
│   ├── Paragraph 1
```

**Ожидаемый результат:**
```
Документ Word
├── Content
│   ├── Paragraph 1
```
**Статус:** Код не должен измениться

### ТС-2: Код с пустыми строками
**Входные данные:**
```
Документ Word

├── Content

│   ├── Paragraph 1
```

**Ожидаемый результат:**
```
Документ Word
├── Content
│   ├── Paragraph 1
```
**Статус:** Пустые строки должны быть удалены

### ТС-3: Код с множественными пустыми строками
**Входные данные:**
```
Документ Word


├── Content


│   ├── Paragraph 1
```

**Ожидаемый результат:**
```
Документ Word
├── Content
│   ├── Paragraph 1
```
**Статус:** Все пустые строки должны быть удалены

### ТС-4: Пустой код
**Входные данные:**
```
(пустая строка)
```

**Ожидаемый результат:**
```
(пустая строка)
```
**Статус:** Метод должен вернуть пустую строку, вставка не должна выполняться

### ТС-5: Код, состоящий только из пустых строк
**Входные данные:**
```


```

**Ожидаемый результат:**
```
(пустая строка)
```
**Статус:** Метод должен вернуть пустую строку, вставка не должна выполняться

### ТС-6: Код с пробелами и табуляциями
**Входные данные:**
```
Документ Word
    (строка с пробелами)
	(строка с табуляцией)
```

**Ожидаемый результат:**
```
Документ Word
    (строка с пробелами)
	(строка с табуляциями)
```
**Статус:** Строки с пробелами/табуляциями должны сохраняться, пустые строки удаляться

### ТС-7: Код с Windows-форматом переносов строк (`\r\n`)
**Входные данные:**
```
Документ Word\r\n\r\n├── Content
```

**Ожидаемый результат:**
```
Документ Word\n├── Content
```
**Статус:** Пустые строки должны быть удалены, формат нормализован

### ТС-8: Код с Unix-форматом переносов строк (`\n`)
**Входные данные:**
```
Документ Word\n\n├── Content
```

**Ожидаемый результат:**
```
Документ Word\n├── Content
```
**Статус:** Пустые строки должны быть удалены

### ТС-9: Код с Mac-форматом переносов строк (`\r`)
**Входные данные:**
```
Документ Word\r\r├── Content
```

**Ожидаемый результат:**
```
Документ Word\n├── Content
```
**Статус:** Пустые строки должны быть удалены, формат нормализован

### ТС-10: Код с сохранением отступов
**Входные данные:**
```
Документ Word

    ├── Content

        │   ├── Paragraph 1
```

**Ожидаемый результат:**
```
Документ Word
    ├── Content
        │   ├── Paragraph 1
```
**Статус:** Отступы должны сохраняться, пустые строки удаляться

## 7. Критерии приемки

### КП-1: Функциональность
- ✅ Все пустые строки удаляются из кода перед вставкой
- ✅ Структура и порядок непустых строк сохраняются
- ✅ Отступы в начале строк сохраняются
- ✅ Различные форматы переносов строк обрабатываются корректно

### КП-2: Качество кода
- ✅ Код соответствует стандартам проекта
- ✅ Добавлены XML-комментарии к новому методу
- ✅ Обработаны граничные случаи (null, пустые строки и т.д.)

### КП-3: Тестирование
- ✅ Все тестовые случаи (ТС-1 - ТС-10) пройдены успешно
- ✅ Существующий функционал не нарушен
- ✅ Форматирование и подсветка синтаксиса работают корректно

### КП-4: Результат
- ✅ В Markdown-представлении блоков кода нет лишних пустых строк
- ✅ Блоки кода отображаются компактно и читабельно

## 8. Риски и ограничения

### Р-1: Потеря форматирования
**Риск:** Удаление пустых строк может изменить визуальное представление кода  
**Митигация:** Пустые строки не являются частью логической структуры кода, их удаление не влияет на функциональность

### Р-2: Производительность
**Риск:** Обработка очень больших блоков кода может занять время  
**Митигация:** Операции `Split` и `Where` оптимизированы в .NET, обработка до 10,000 строк выполняется быстро

### Р-3: Обратная совместимость
**Риск:** Изменения могут повлиять на существующие блоки кода  
**Митигация:** Изменения затрагивают только процесс вставки, существующие блоки кода не изменяются

## 9. Дополнительные улучшения (опционально)

### У-1: Настройка поведения
Добавить параметр в `WordCodeBlock`, позволяющий выбирать, удалять ли пустые строки:
```csharp
public bool RemoveEmptyLines { get; set; } = true;
```

### У-2: Логирование
Добавить логирование процесса нормализации для отладки:
```csharp
System.Diagnostics.Debug.WriteLine($"Нормализация кода: {lines.Count} строк → {nonEmptyLines.Count()} строк");
```

### У-3: Сохранение минимального количества пустых строк
Вместо полного удаления всех пустых строк, заменять множественные пустые строки на одну:
```csharp
// Заменяем 2+ пустые строки подряд на одну пустую строку
```

## 10. Сроки и приоритет

**Приоритет:** Высокий  
**Сложность:** Низкая  
**Оценка времени:** 2-4 часа  
**Зависимости:** Нет

## 11. Примечания

- Изменения затрагивают только метод `ApplyToWord` класса `WordCodeBlock`
- Не требуется изменений в других частях системы
- Решение простое и эффективное
- Обратная совместимость гарантирована

