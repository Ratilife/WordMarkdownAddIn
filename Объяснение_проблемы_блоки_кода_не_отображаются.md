# Объяснение проблемы: Блоки кода не отображаются в Word

## Суть проблемы

Блоки кода (```csharp ... ```), которые находятся **внутри элементов списка**, не отображаются в документе Word, потому что они **пропускаются** при обработке.

## Пошаговое объяснение

### Шаг 1: Структура Markdown

Когда у вас есть такой Markdown:

```markdown
1. **Добавить логирование:**
   ```csharp
   LogError("Ошибка");
   ```
```

Markdig парсит это следующим образом:

```
ListBlock (нумерованный список)
  └── ListItemBlock (элемент списка #1)
        ├── ParagraphBlock (текст "Добавить логирование:")
        └── CodeBlock (код "LogError(\"Ошибка\");")
```

### Шаг 2: Обработка в `ApplyMarkdownToWord()`

**Файл:** `Services/MarkdownToWordFormatter.cs`, строки 677-702

Когда код доходит до обработки `ListBlock`:

```csharp
foreach(var block in document)
{
    if (block is ListBlock listBlock)
    {
        var listItems = ProcessListItems(listBlock);  // ← Вызывается специальный метод
        elements.AddRange(listItems);
    }
    else
    {
        IWordElement element = ProcessBlock(block);  // ← Для обычных блоков (вне списков)
        elements.Add(element);
    }
}
```

**Важно:** Списки обрабатываются **отдельно** через метод `ProcessListItems()`, а не через общий `ProcessBlock()`.

### Шаг 3: Обработка элементов списка в `ProcessListItems()`

**Файл:** `Services/MarkdownToWordFormatter.cs`, строки 502-528

Внутри `ProcessListItems()` происходит следующее:

```csharp
foreach (var item in listBlock)  // Перебираем элементы списка
{
    if (item is ListItemBlock listItem)
    {
        foreach (var block in listItem)  // ← Перебираем блоки ВНУТРИ элемента списка
        {
            if (block is ParagraphBlock paragraph)  // ← ПРОВЕРКА ТОЛЬКО НА ParagraphBlock!
            {
                // Обрабатываем только параграфы
                var itemFormattedText = ConvertInlineToWordFormattedText(paragraph.Inline);
                itemContents.Add(itemFormattedText);
            }
            else
            {
                // ← ВОТ ТУТ ПРОБЛЕМА!
                // Блоки кода (CodeBlock) попадают сюда и ПРОПУСКАЮТСЯ
                System.Diagnostics.Debug.WriteLine("не ParagraphBlock, пропускаем");
            }
        }
    }
}
```

### Шаг 4: Что происходит с блоком кода

Когда код доходит до `CodeBlock` внутри элемента списка:

1. ✅ Блок распознается: `blockType = "CodeBlock"`
2. ❌ Проверка `if (block is ParagraphBlock)` возвращает `false`
3. ❌ Блок попадает в `else` и **пропускается**
4. ❌ Блок кода **не добавляется** в `itemContents`
5. ❌ Блок кода **не создается** как `WordCodeBlock`
6. ❌ Блок кода **не отображается** в Word

### Шаг 5: Архитектурное ограничение

**Дополнительная проблема:** Даже если бы блок кода обрабатывался, его нельзя было бы добавить в элемент списка.

**Файл:** `Services/IWordElement.cs`, строка 432

```csharp
public class WordListItem : IWordElement
{
    public List<WordFormattedText> Contents { get; set; }  // ← Только WordFormattedText!
}
```

**Проблема:** 
- `Contents` имеет тип `List<WordFormattedText>`
- `WordCodeBlock` является `IWordElement`, но **не является** `WordFormattedText`
- Поэтому `WordCodeBlock` **нельзя добавить** в `Contents`

## Визуальная схема проблемы

```
Markdown:
  1. Текст
     ```csharp
     код
     ```

Парсинг Markdig:
  ListBlock
    └── ListItemBlock
          ├── ParagraphBlock ("Текст")  ✅
          └── CodeBlock ("код")         ❌

Обработка в ProcessListItems():
  foreach (block in listItem)
    if (block is ParagraphBlock)  ✅ → Обрабатывается
    else                          ❌ → CodeBlock пропускается!

Результат в Word:
  1. Текст  ✅
     [блок кода отсутствует]  ❌
```

## Почему блоки кода вне списков работают?

Блоки кода, которые находятся **на верхнем уровне** документа (не внутри списков), обрабатываются через общий метод `ProcessBlock()`:

**Файл:** `Services/MarkdownToWordFormatter.cs`, строки 585-587

```csharp
else if (block is CodeBlock codeBlock)
{
    return ProcessCodeBlock(codeBlock);  // ← Обрабатывается правильно
}
```

**Пример:**
```markdown
Обычный текст

```csharp
код
```

Еще текст
```

Это работает, потому что:
1. `CodeBlock` находится на верхнем уровне документа
2. Обрабатывается через `ProcessBlock()` → `ProcessCodeBlock()`
3. Создается `WordCodeBlock`
4. Отображается в Word

## Итоговая причина

**Главная причина:** В методе `ProcessListItems()` на строке 508 проверяется **только** `block is ParagraphBlock`. Все остальные типы блоков (включая `CodeBlock`) попадают в блок `else` на строке 524 и **пропускаются**.

**Дополнительная причина:** Даже если бы блоки кода обрабатывались, их нельзя было бы добавить в `WordListItem`, так как `Contents` имеет тип `List<WordFormattedText>`, а не `List<IWordElement>`.

## Что нужно исправить

1. **Добавить обработку `CodeBlock`** в метод `ProcessListItems()` (строка 508)
2. **Изменить тип `Contents`** в `WordListItem` с `List<WordFormattedText>` на `List<IWordElement>` (строка 432)
3. **Обновить метод `WordListItem.ApplyToWord()`** для обработки различных типов элементов (`WordFormattedText` и `WordCodeBlock`)

