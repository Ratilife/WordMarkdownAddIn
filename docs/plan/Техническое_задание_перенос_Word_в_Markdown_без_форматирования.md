# Техническое задание: Перенос текста из Word в Markdown без форматирования

## 1. Общая информация

**Дата создания:** 28.12.2025  
**Приоритет:** Высокий  
**Статус:** К выполнению  
**Основание:** Требование пользователя для переноса текста, уже записанного по правилам Markdown в документе Word

## 2. Цель и задачи

### 2.1. Цель
Реализовать функционал переноса текста из документа Word в Markdown без преобразования форматирования. В документе Word уже записан текст по правилам Markdown, поэтому требуется только извлечение текстового содержимого и перенос его в панель Markdown.

### 2.2. Задачи
1. Создать новый сервисный модуль для извлечения текста без форматирования
2. Реализовать метод извлечения текста из активного документа Word
3. Подключить обработчик события для кнопки `btnConvertMD_DocNotF`
4. Обеспечить отображение извлеченного текста в панели Markdown
5. Обработать возможные ошибки и исключительные ситуации

## 3. Описание функционала

### 3.1. Назначение
Функционал предназначен для случаев, когда:
- В документе Word уже записан текст по правилам Markdown (например, заголовки с символами `#`, списки с маркерами `-` или `*`, блоки кода с тройными кавычками и т.д.)
- Пользователю необходимо перенести этот текст в панель Markdown без преобразования форматирования Word
- Требуется простое извлечение текстового содержимого документа

### 3.2. Отличие от существующего функционала
- **Существующий функционал (`btnConvert`):** Преобразует форматирование Word (стили, шрифты, таблицы) в Markdown-синтаксис
- **Новый функционал (`btnConvertMD_DocNotF`):** Извлекает только текстовое содержимое без анализа форматирования

### 3.3. Пример использования
**Исходный документ Word:**
```
# Заголовок 1

## Заголовок 2

Текст параграфа.

- Элемент списка 1
- Элемент списка 2

```csharp
public class Example { }
```
```

**Результат в панели Markdown:**
```markdown
# Заголовок 1

## Заголовок 2

Текст параграфа.

- Элемент списка 1
- Элемент списка 2

```csharp
public class Example { }
```
```

**Примечание:** Текст переносится "как есть", без преобразования форматирования Word в Markdown-синтаксис.

## 4. Архитектура решения

### 4.1. Структура модулей

#### 4.1.1. Новый сервисный модуль
**Файл:** `Services/WordToMarkdownPlainTextService.cs`  
**Назначение:** Извлечение текста из документа Word без форматирования

**Класс:** `WordToMarkdownPlainTextService`
- **Зависимости:** 
  - `Microsoft.Office.Interop.Word` (для работы с Word API)
  - `Globals.ThisAddIn` (для доступа к активному документу)
- **Ответственность:**
  - Извлечение текстового содержимого документа
  - Обработка пустых параграфов
  - Нормализация переносов строк
  - Обработка ошибок

#### 4.1.2. Модификация существующего модуля
**Файл:** `MarkdownRibbon.cs`  
**Изменения:** Добавление обработчика события для кнопки `btnConvertMD_DocNotF`

### 4.2. Взаимодействие компонентов

```
┌─────────────────────┐
│  MarkdownRibbon.cs  │
│  (UI обработчик)    │
└──────────┬──────────┘
           │
           │ Вызов метода
           ▼
┌──────────────────────────────────┐
│ WordToMarkdownPlainTextService.cs │
│  (Сервис извлечения текста)       │
└──────────┬────────────────────────┘
           │
           │ Извлечение текста
           ▼
┌─────────────────────┐
│  Document.Content   │
│  (Word API)         │
└──────────┬──────────┘
           │
           │ Текстовое содержимое
           ▼
┌─────────────────────┐
│  TaskPaneControl    │
│  SetMarkdown()      │
└─────────────────────┘
```

## 5. Детальная спецификация

### 5.1. Класс `WordToMarkdownPlainTextService`

#### 5.1.1. Конструктор
```csharp
public WordToMarkdownPlainTextService()
```
**Описание:** Инициализирует сервис, получает ссылку на активный документ Word.

**Логика:**
1. Получить экземпляр приложения Word через `Globals.ThisAddIn.Application`
2. Получить активный документ через `Application.ActiveDocument`
3. Проверить, что активный документ существует
4. Выбросить исключение, если документ не найден

**Исключения:**
- `System.Exception` с сообщением "Нет активного документа Word." - если активный документ отсутствует

#### 5.1.2. Метод `ExtractPlainText()`
```csharp
public string ExtractPlainText()
```
**Описание:** Извлекает текстовое содержимое документа Word без форматирования.

**Возвращаемое значение:** `string` - текстовое содержимое документа

**Алгоритм:**
1. Получить текстовое содержимое документа через `Document.Content.Text`
2. Нормализовать переносы строк:
   - Заменить `\r\n` на `\n` (унификация Windows-переносов)
   - Заменить одиночные `\r` на `\n` (унификация Mac-переносов)
3. Обработать пустые параграфы:
   - Убрать множественные пустые строки подряд (более 2) - заменить на 2
   - Сохранить одинарные и двойные переносы строк (для корректного отображения Markdown)
4. Убрать пустые строки в начале и конце документа
5. Вернуть нормализованный текст

**Особенности обработки:**
- **Символы конца параграфа:** Word использует символы `\r` (возврат каретки) и `\a` (звонок) для обозначения конца параграфа. Эти символы должны быть удалены или заменены на `\n`
- **Пустые параграфы:** Пустые параграфы в Word создают пустые строки. В Markdown пустые строки используются для разделения блоков, поэтому их нужно сохранить, но нормализовать
- **Множественные переносы:** Если в документе Word есть несколько пустых параграфов подряд, они создают множественные пустые строки. Нужно нормализовать их до максимум 2 пустых строк подряд

**Обработка ошибок:**
- Обернуть логику в `try-catch`
- В случае ошибки логировать сообщение через `System.Diagnostics.Debug.WriteLine`
- Возвращать пустую строку в случае ошибки

#### 5.1.3. Вспомогательные методы (опционально)

##### Метод `NormalizeLineBreaks(string text)`
```csharp
private string NormalizeLineBreaks(string text)
```
**Описание:** Нормализует переносы строк в тексте.

**Параметры:**
- `text` - исходный текст

**Возвращаемое значение:** Текст с нормализованными переносами строк

**Логика:**
1. Заменить `\r\n` на `\n`
2. Заменить одиночные `\r` на `\n`
3. Вернуть результат

##### Метод `NormalizeEmptyLines(string text)`
```csharp
private string NormalizeEmptyLines(string text)
```
**Описание:** Нормализует множественные пустые строки подряд.

**Параметры:**
- `text` - исходный текст

**Возвращаемое значение:** Текст с нормализованными пустыми строками

**Логика:**
1. Заменить 3 и более переносов строк подряд (`\n\n\n+`) на 2 переноса (`\n\n`)
2. Повторять замену, пока есть множественные переносы
3. Вернуть результат

### 5.2. Модификация `MarkdownRibbon.cs`

#### 5.2.1. Обработчик события `btnConvertMD_DocNotF_Click`
```csharp
private void btnConvertMD_DocNotF_Click(object sender, RibbonControlEventArgs e)
```
**Описание:** Обработчик события нажатия кнопки "Markdown → Word (без форматирования)".

**Логика:**
1. Обернуть логику в `try-catch` для обработки ошибок
2. Создать экземпляр `WordToMarkdownPlainTextService`
3. Вызвать метод `ExtractPlainText()` для извлечения текста
4. Установить извлеченный текст в панель Markdown через `ThisAddIn.PaneControl.SetMarkdown(markdown)`
5. Показать сообщение об успешном выполнении через `MessageBox.Show`
6. В случае ошибки показать сообщение об ошибке через `MessageBox.Show`

**Сообщения пользователю:**
- **Успех:** "Текст из документа Word успешно перенесен в Markdown!" (тип: Information)
- **Ошибка:** "Ошибка при переносе текста: {сообщение об ошибке}" (тип: Error)

#### 5.2.2. Подключение обработчика события
**Файл:** `MarkdownRibbon.Designer.cs`  
**Место:** В методе `InitializeComponent()`, после создания кнопки `btnConvertMD_DocNotF`

**Изменение:**
Добавить строку подключения обработчика события:
```csharp
this.btnConvertMD_DocNotF.Click += new Microsoft.Office.Tools.Ribbon.RibbonControlEventHandler(this.btnConvertMD_DocNotF_Click);
```

**Текущее состояние:**
- Кнопка `btnConvertMD_DocNotF` создана (строка 64)
- Кнопка добавлена в группу `grpConvert` (строка 238)
- Кнопка имеет метку "Markdown → Word (без форматирования)" (строка 256)
- **Обработчик события не подключен** (требуется добавить)

## 6. Детальный план реализации

### Этап 1: Создание сервисного модуля (30 минут)

#### Задача 1.1: Создать файл `Services/WordToMarkdownPlainTextService.cs`
1. Создать новый файл в папке `Services`
2. Добавить необходимые `using` директивы:
   - `Microsoft.Office.Interop.Word`
   - `System`
   - `System.Text`
3. Объявить namespace: `WordMarkdownAddIn.Services`
4. Объявить класс: `public class WordToMarkdownPlainTextService`

#### Задача 1.2: Реализовать конструктор
1. Добавить приватные поля:
   - `private readonly Application _wordApp;`
   - `private readonly Document _activeDoc;`
2. Реализовать конструктор:
   - Получить `Globals.ThisAddIn.Application`
   - Получить `Application.ActiveDocument`
   - Проверить наличие активного документа
   - Выбросить исключение при отсутствии документа

#### Задача 1.3: Реализовать метод `ExtractPlainText()`
1. Обернуть логику в `try-catch`
2. Получить текстовое содержимое через `_activeDoc.Content.Text`
3. Вызвать вспомогательные методы для нормализации:
   - `NormalizeLineBreaks()`
   - `NormalizeEmptyLines()`
4. Убрать пустые строки в начале и конце через `TrimStart()` и `TrimEnd()`
5. Вернуть результат
6. В `catch` блоке логировать ошибку и возвращать пустую строку

#### Задача 1.4: Реализовать вспомогательные методы
1. Реализовать `NormalizeLineBreaks(string text)`:
   - Заменить `\r\n` на `\n`
   - Заменить `\r` на `\n`
   - Вернуть результат
2. Реализовать `NormalizeEmptyLines(string text)`:
   - Использовать цикл `while` для замены `\n\n\n` на `\n\n`
   - Повторять, пока есть множественные переносы
   - Вернуть результат

### Этап 2: Модификация обработчика событий (20 минут)

#### Задача 2.1: Добавить обработчик в `MarkdownRibbon.cs`
1. Открыть файл `MarkdownRibbon.cs`
2. Добавить метод `btnConvertMD_DocNotF_Click`:
   - Сигнатура: `private void btnConvertMD_DocNotF_Click(object sender, RibbonControlEventArgs e)`
   - Обернуть в `try-catch`
   - Создать экземпляр `WordToMarkdownPlainTextService`
   - Вызвать `ExtractPlainText()`
   - Установить результат через `ThisAddIn.PaneControl.SetMarkdown()`
   - Показать сообщение об успехе
   - В `catch` показать сообщение об ошибке

#### Задача 2.2: Подключить обработчик в `MarkdownRibbon.Designer.cs`
1. Открыть файл `MarkdownRibbon.Designer.cs`
2. Найти место создания кнопки `btnConvertMD_DocNotF` (около строки 256)
3. Добавить подключение обработчика события:
   ```csharp
   this.btnConvertMD_DocNotF.Click += new Microsoft.Office.Tools.Ribbon.RibbonControlEventHandler(this.btnConvertMD_DocNotF_Click);
   ```

### Этап 3: Тестирование (45 минут)

#### Задача 3.1: Подготовка тестовых документов
1. Создать тестовый документ Word с Markdown-текстом:
   - Заголовки разных уровней (`#`, `##`, `###`)
   - Параграфы с текстом
   - Списки (маркированные и нумерованные)
   - Блоки кода (с тройными кавычками)
   - Пустые строки между блоками
   - Таблицы (если поддерживаются)

#### Задача 3.2: Функциональное тестирование
1. Запустить приложение Word с надстройкой
2. Открыть тестовый документ
3. Нажать кнопку `btnConvertMD_DocNotF`
4. Проверить результат в панели Markdown:
   - Текст должен быть извлечен "как есть"
   - Переносы строк должны быть сохранены
   - Пустые строки должны быть нормализованы (не более 2 подряд)
   - Не должно быть лишних символов (например, `\r`, `\a`)

#### Задача 3.3: Тестирование граничных случаев
1. **Пустой документ:**
   - Создать пустой документ Word
   - Нажать кнопку
   - Ожидаемый результат: Пустая строка или сообщение об отсутствии содержимого

2. **Документ только с пустыми параграфами:**
   - Создать документ с несколькими пустыми параграфами
   - Нажать кнопку
   - Ожидаемый результат: Пустая строка или минимальное количество пустых строк

3. **Документ с множественными переносами строк:**
   - Создать документ с 5+ пустыми параграфами подряд
   - Нажать кнопку
   - Ожидаемый результат: Максимум 2 пустые строки подряд

4. **Документ без активного документа:**
   - Закрыть все документы Word
   - Попытаться нажать кнопку
   - Ожидаемый результат: Сообщение об ошибке "Нет активного документа Word."

#### Задача 3.4: Сравнение с существующим функционалом
1. Создать документ Word с Markdown-текстом
2. Нажать кнопку `btnConvert` (Word → Markdown с форматированием)
3. Записать результат
4. Нажать кнопку `btnConvertMD_DocNotF` (Word → Markdown без форматирования)
5. Сравнить результаты:
   - Результат `btnConvertMD_DocNotF` должен содержать исходный Markdown-текст "как есть"
   - Результат `btnConvert` может преобразовывать форматирование Word в Markdown

### Этап 4: Документирование и финализация (15 минут)

#### Задача 4.1: Добавить XML-комментарии
1. Добавить XML-комментарии к классу `WordToMarkdownPlainTextService`
2. Добавить XML-комментарии к методу `ExtractPlainText()`
3. Добавить XML-комментарии к вспомогательным методам

#### Задача 4.2: Проверка кода
1. Проверить компиляцию проекта
2. Убедиться, что нет предупреждений компилятора
3. Проверить соответствие стилю кодирования проекта

## 7. Критерии приемки

### 7.1. Функциональные требования

1. **Извлечение текста:**
   - Метод `ExtractPlainText()` должен извлекать текстовое содержимое активного документа Word
   - Текст должен извлекаться без преобразования форматирования

2. **Нормализация переносов строк:**
   - Все переносы строк должны быть унифицированы до `\n`
   - Символы `\r` и `\a` должны быть удалены или заменены

3. **Нормализация пустых строк:**
   - Множественные пустые строки (3+) должны быть заменены на максимум 2
   - Одинарные и двойные пустые строки должны быть сохранены

4. **Обработка ошибок:**
   - При отсутствии активного документа должно показываться сообщение об ошибке
   - При других ошибках должно показываться сообщение с описанием ошибки

5. **Интеграция с UI:**
   - Кнопка `btnConvertMD_DocNotF` должна быть активна
   - При нажатии кнопки текст должен отображаться в панели Markdown
   - Должно показываться сообщение об успешном выполнении

### 7.2. Тестовые сценарии

#### Тест 1: Базовое извлечение текста
**Исходный Word:**
```
# Заголовок

Текст параграфа.
```

**Ожидаемый Markdown:**
```markdown
# Заголовок

Текст параграфа.
```

**Критерий:** Текст извлечен "как есть", переносы строк сохранены.

#### Тест 2: Документ с блоками кода
**Исходный Word:**
```
```csharp
public class Example { }
```
```

**Ожидаемый Markdown:**
```markdown
```csharp
public class Example { }
```
```

**Критерий:** Блок кода извлечен с сохранением тройных кавычек и языка.

#### Тест 3: Документ со списками
**Исходный Word:**
```
- Элемент 1
- Элемент 2
- Элемент 3
```

**Ожидаемый Markdown:**
```markdown
- Элемент 1
- Элемент 2
- Элемент 3
```

**Критерий:** Список извлечен с сохранением маркеров.

#### Тест 4: Нормализация множественных пустых строк
**Исходный Word:**
```
# Заголовок

[5 пустых параграфов]

Текст
```

**Ожидаемый Markdown:**
```markdown
# Заголовок


Текст
```

**Критерий:** Множественные пустые строки нормализованы до максимум 2.

#### Тест 5: Пустой документ
**Исходный Word:**
```
[пустой документ]
```

**Ожидаемый Markdown:**
```markdown
[пустая строка или минимальное содержимое]
```

**Критерий:** Пустой документ обрабатывается без ошибок.

#### Тест 6: Обработка ошибки (нет активного документа)
**Действие:**
1. Закрыть все документы Word
2. Нажать кнопку `btnConvertMD_DocNotF`

**Ожидаемый результат:**
- Показывается сообщение об ошибке: "Ошибка при переносе текста: Нет активного документа Word."

**Критерий:** Ошибка обрабатывается корректно, приложение не падает.

### 7.3. Требования к производительности

1. **Скорость извлечения:**
   - Извлечение текста из документа размером до 10 000 символов должно выполняться менее чем за 1 секунду
   - Извлечение текста из документа размером до 100 000 символов должно выполняться менее чем за 5 секунд

2. **Использование памяти:**
   - Потребление памяти не должно значительно увеличиваться при обработке больших документов

### 7.4. Требования к совместимости

1. **Версии Word:**
   - Функционал должен работать с Microsoft Word 2016 и выше
   - Функционал должен работать с Microsoft Word 365

2. **Обратная совместимость:**
   - Новый функционал не должен влиять на существующий функционал (`btnConvert`, `btnConvertMD_Doc`)
   - Все существующие тесты должны проходить

## 8. Риски и ограничения

### 8.1. Риски

1. **Риск: Потеря форматирования при извлечении текста**
   - **Описание:** Метод `Document.Content.Text` может не сохранять некоторые специальные символы или форматирование
   - **Вероятность:** Низкая
   - **Влияние:** Среднее
   - **Митигация:** Это ожидаемое поведение, так как функционал предназначен для извлечения текста без форматирования. Если потребуется сохранение специальных символов, можно использовать альтернативные методы извлечения

2. **Риск: Проблемы с кодировкой**
   - **Описание:** Текст может содержать символы в различных кодировках, которые могут быть неправильно извлечены
   - **Вероятность:** Средняя
   - **Влияние:** Среднее
   - **Митигация:** Word API обычно корректно обрабатывает кодировки. При необходимости можно добавить явное указание кодировки

3. **Риск: Производительность на больших документах**
   - **Описание:** Обработка очень больших документов (более 1 МБ текста) может быть медленной
   - **Вероятность:** Низкая
   - **Влияние:** Низкое
   - **Митигация:** Оптимизировать алгоритм нормализации, использовать `StringBuilder` для конкатенации строк

### 8.2. Ограничения

1. **Ограничение: Только текстовое содержимое**
   - Функционал извлекает только текстовое содержимое документа
   - Изображения, таблицы и другие объекты не извлекаются
   - **Обоснование:** Это соответствует назначению функционала - извлечение текста без форматирования

2. **Ограничение: Нет анализа структуры**
   - Функционал не анализирует структуру документа (заголовки, списки, таблицы)
   - Текст извлекается "как есть" из `Document.Content.Text`
   - **Обоснование:** Это соответствует назначению функционала - простой перенос текста

3. **Ограничение: Зависимость от Word API**
   - Функционал зависит от Microsoft Word Interop API
   - Требуется установленный Microsoft Word
   - **Обоснование:** Это стандартное требование для надстройки Word

## 9. Дополнительные замечания

### 9.1. Альтернативные подходы

1. **Использование `Document.Content.Text` (выбранный подход):**
   - **Преимущества:** Простота реализации, быстрое выполнение
   - **Недостатки:** Может не сохранять некоторые специальные символы

2. **Итерация по параграфам:**
   - **Преимущества:** Больше контроля над процессом извлечения
   - **Недостатки:** Более сложная реализация, медленнее выполнение

3. **Использование `Document.Range().Text`:**
   - **Преимущества:** Аналогично `Content.Text`, но с возможностью указания диапазона
   - **Недостатки:** Требует указания диапазона

**Выбранный подход:** Использование `Document.Content.Text` как наиболее простой и эффективный для данной задачи.

### 9.2. Возможные улучшения в будущем

1. **Опция сохранения специальных символов:**
   - Добавить параметр для сохранения или удаления специальных символов (например, неразрывные пробелы)

2. **Опция выборочного извлечения:**
   - Добавить возможность извлечения текста только из выделенного фрагмента документа

3. **Предпросмотр результата:**
   - Добавить возможность предпросмотра извлеченного текста перед установкой в панель Markdown

4. **Настройки нормализации:**
   - Добавить настройки для управления нормализацией пустых строк (например, максимальное количество пустых строк)

### 9.3. Связанные компоненты

1. **Существующие сервисы:**
   - `WordToMarkdownService` - преобразование Word в Markdown с форматированием (используется кнопкой `btnConvert`)
   - `MarkdownToWordFormatter` - преобразование Markdown в Word (используется кнопкой `btnConvertMD_Doc`)

2. **UI компоненты:**
   - `MarkdownRibbon` - лента с кнопками управления
   - `TaskPaneControl` - панель с редактором Markdown

3. **Зависимости:**
   - Microsoft.Office.Interop.Word
   - Microsoft.Office.Tools.Ribbon

## 10. Контрольный список выполнения

### Подготовка
- [ ] Изучена структура проекта
- [ ] Изучен существующий код `WordToMarkdownService`
- [ ] Изучен код обработчиков событий в `MarkdownRibbon.cs`
- [ ] Подготовлены тестовые документы Word

### Реализация
- [ ] Создан файл `Services/WordToMarkdownPlainTextService.cs`
- [ ] Реализован конструктор класса
- [ ] Реализован метод `ExtractPlainText()`
- [ ] Реализован метод `NormalizeLineBreaks()`
- [ ] Реализован метод `NormalizeEmptyLines()`
- [ ] Добавлен обработчик `btnConvertMD_DocNotF_Click` в `MarkdownRibbon.cs`
- [ ] Подключен обработчик события в `MarkdownRibbon.Designer.cs`
- [ ] Добавлены XML-комментарии к классу и методам

### Тестирование
- [ ] Выполнен тест 1: Базовое извлечение текста
- [ ] Выполнен тест 2: Документ с блоками кода
- [ ] Выполнен тест 3: Документ со списками
- [ ] Выполнен тест 4: Нормализация множественных пустых строк
- [ ] Выполнен тест 5: Пустой документ
- [ ] Выполнен тест 6: Обработка ошибки (нет активного документа)
- [ ] Проверена производительность на больших документах
- [ ] Проверена совместимость с существующим функционалом

### Финализация
- [ ] Код проверен на ошибки компиляции
- [ ] Код проверен на соответствие стилю проекта
- [ ] Все критерии приемки выполнены
- [ ] Документация обновлена

## 11. Контакты и ответственные

**Разработчик:** [Указать имя]  
**Тестировщик:** [Указать имя]  
**Ревьюер кода:** [Указать имя]

---

**Дата создания ТЗ:** 28.12.2025  
**Версия:** 1.0  
**Статус:** Готово к выполнению

