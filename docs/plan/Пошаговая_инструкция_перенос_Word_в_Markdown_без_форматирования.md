# Пошаговая инструкция: Перенос текста из Word в Markdown без форматирования

## Оглавление
1. [Подготовка к работе](#подготовка-к-работе)
2. [Этап 1: Создание сервисного модуля](#этап-1-создание-сервисного-модуля)
3. [Этап 2: Модификация обработчика событий](#этап-2-модификация-обработчика-событий)
4. [Этап 3: Тестирование](#этап-3-тестирование)
5. [Этап 4: Документирование и финализация](#этап-4-документирование-и-финализация)
6. [Контрольный список выполнения](#контрольный-список-выполнения)

---

## Подготовка к работе

### Шаг 1.1: Открытие проекта в Visual Studio

1. Запустите **Visual Studio 2022** (или более новую версию)
2. Откройте решение `WordMarkdownAddIn.sln` из корневой папки проекта
3. Дождитесь загрузки всех зависимостей и восстановления пакетов NuGet

### Шаг 1.2: Проверка структуры проекта

Убедитесь, что в проекте присутствуют следующие файлы и папки:

```
WordMarkdownAddIn/
├── Services/
│   ├── WordToMarkdownService.cs      (существующий сервис для справки)
│   └── [здесь будет создан новый файл]
├── MarkdownRibbon.cs                 (файл для модификации)
├── MarkdownRibbon.Designer.cs        (файл уже настроен)
└── Controls/
    └── TaskPaneControl.cs            (для справки по SetMarkdown)
```

### Шаг 1.3: Изучение существующего кода

**Важно:** Перед началом реализации изучите существующий код для понимания стиля и структуры проекта.

1. Откройте файл `Services/WordToMarkdownService.cs`
   - Обратите внимание на конструктор (строки 31-38)
   - Изучите метод `ExtractDocumentContent()` (строки 40-43)
   - Это поможет понять, как работать с Word API

2. Откройте файл `MarkdownRibbon.cs`
   - Изучите метод `btnConvert_Click` (строки 225-238)
   - Это пример обработчика события кнопки
   - Обратите внимание на структуру try-catch и использование `ThisAddIn.PaneControl.SetMarkdown()`

3. Проверьте файл `MarkdownRibbon.Designer.cs`
   - Убедитесь, что кнопка `btnConvertMD_DocNotF` уже создана (строка 64)
   - Проверьте, что обработчик события уже подключен (строка 258)

---

## Этап 1: Создание сервисного модуля

### Шаг 1.1: Создание файла сервиса

1. В **Solution Explorer** найдите папку `Services`
2. **Правой кнопкой мыши** на папке `Services` → **Add** → **Class...**
3. В диалоговом окне введите имя класса: `WordToMarkdownPlainTextService`
4. Нажмите **Add**

**Результат:** Создан файл `Services/WordToMarkdownPlainTextService.cs`

### Шаг 1.2: Добавление необходимых using-директив

Откройте созданный файл и замените содержимое на следующее:

```csharp
using Microsoft.Office.Interop.Word;
using System;
using System.Text;
using System.Text.RegularExpressions;

namespace WordMarkdownAddIn.Services
{
    /// <summary>
    /// Сервис для извлечения текстового содержимого документа Word без форматирования.
    /// Предназначен для случаев, когда в документе Word уже записан текст по правилам Markdown.
    /// </summary>
    public class WordToMarkdownPlainTextService
    {
        private readonly Application _wordApp;
        private readonly Document _activeDoc;

        /// <summary>
        /// Инициализирует сервис, получая ссылку на активный документ Word.
        /// </summary>
        /// <exception cref="System.Exception">Выбрасывается, если активный документ отсутствует.</exception>
        public WordToMarkdownPlainTextService()
        {
            _wordApp = Globals.ThisAddIn.Application;
            _activeDoc = _wordApp.ActiveDocument;

            if (_activeDoc == null)
                throw new System.Exception("Нет активного документа Word.");
        }

        /// <summary>
        /// Извлекает текстовое содержимое документа Word без форматирования.
        /// </summary>
        /// <returns>Текстовое содержимое документа с нормализованными переносами строк.</returns>
        public string ExtractPlainText()
        {
            try
            {
                // Получаем текстовое содержимое документа
                string text = _activeDoc.Content.Text;

                // Нормализуем переносы строк
                text = NormalizeLineBreaks(text);

                // Нормализуем множественные пустые строки
                text = NormalizeEmptyLines(text);

                // Убираем пустые строки в начале и конце
                text = text.TrimStart('\n', '\r', ' ', '\t');
                text = text.TrimEnd('\n', '\r', ' ', '\t');

                return text;
            }
            catch (Exception ex)
            {
                // Логируем ошибку для отладки
                System.Diagnostics.Debug.WriteLine($"Ошибка при извлечении текста: {ex.Message}");
                return string.Empty;
            }
        }

        /// <summary>
        /// Нормализует переносы строк в тексте.
        /// Заменяет все варианты переносов строк (Windows, Mac, Unix) на единый формат (\n).
        /// </summary>
        /// <param name="text">Исходный текст.</param>
        /// <returns>Текст с нормализованными переносами строк.</returns>
        private string NormalizeLineBreaks(string text)
        {
            if (string.IsNullOrEmpty(text))
                return text;

            // Заменяем Windows-переносы (\r\n) на \n
            text = text.Replace("\r\n", "\n");

            // Заменяем Mac-переносы (\r) на \n
            text = text.Replace("\r", "\n");

            // Удаляем символы конца параграфа Word (\a - звонок)
            text = text.Replace("\a", "");

            return text;
        }

        /// <summary>
        /// Нормализует множественные пустые строки подряд.
        /// Заменяет 3 и более переносов строк подряд на максимум 2.
        /// </summary>
        /// <param name="text">Исходный текст.</param>
        /// <returns>Текст с нормализованными пустыми строками.</returns>
        private string NormalizeEmptyLines(string text)
        {
            if (string.IsNullOrEmpty(text))
                return text;

            // Заменяем 3 и более переносов строк подряд на 2 переноса
            // Используем цикл while для обработки всех случаев (например, \n\n\n\n\n)
            while (text.Contains("\n\n\n"))
            {
                text = text.Replace("\n\n\n", "\n\n");
            }

            return text;
        }
    }
}
```

**Проверка:**
- Убедитесь, что код компилируется без ошибок (Build → Build Solution или Ctrl+Shift+B)
- Проверьте, что нет предупреждений компилятора

### Шаг 1.3: Проверка компиляции

1. Нажмите **Build** → **Build Solution** (или **Ctrl+Shift+B**)
2. Убедитесь, что проект компилируется без ошибок
3. Если есть ошибки, проверьте:
   - Правильность using-директив
   - Наличие всех необходимых зависимостей
   - Правильность имен namespace

---

## Этап 2: Модификация обработчика событий

### Шаг 2.1: Реализация обработчика в MarkdownRibbon.cs

1. Откройте файл `MarkdownRibbon.cs`
2. Найдите метод `btnConvertMD_DocNotF_Click` (строки 259-262)
3. Замените пустое тело метода на следующую реализацию:

```csharp
private void btnConvertMD_DocNotF_Click(object sender, RibbonControlEventArgs e)
{
    try
    {
        // Создаем экземпляр сервиса для извлечения текста
        var service = new Services.WordToMarkdownPlainTextService();
        
        // Извлекаем текстовое содержимое документа
        string markdown = service.ExtractPlainText();
        
        // Устанавливаем извлеченный текст в панель Markdown
        ThisAddIn.PaneControl.SetMarkdown(markdown);
        
        // Показываем сообщение об успешном выполнении
        MessageBox.Show(
            "Текст из документа Word успешно перенесен в Markdown!",
            "Успех",
            MessageBoxButtons.OK,
            MessageBoxIcon.Information
        );
    }
    catch (Exception ex)
    {
        // Показываем сообщение об ошибке
        MessageBox.Show(
            $"Ошибка при переносе текста: {ex.Message}",
            "Ошибка",
            MessageBoxButtons.OK,
            MessageBoxIcon.Error
        );
    }
}
```

**Проверка:**
- Убедитесь, что метод находится внутри класса `MarkdownRibbon`
- Проверьте, что используется правильный namespace для `Services.WordToMarkdownPlainTextService`
- Убедитесь, что обработчик уже подключен в `MarkdownRibbon.Designer.cs` (строка 258)

### Шаг 2.2: Проверка подключения обработчика события

1. Откройте файл `MarkdownRibbon.Designer.cs`
2. Найдите строку 258, где должен быть подключен обработчик:

```csharp
this.btnConvertMD_DocNotF.Click += new Microsoft.Office.Tools.Ribbon.RibbonControlEventHandler(this.btnConvertMD_DocNotF_Click);
```

**Важно:** Если эта строка отсутствует, добавьте её в метод `InitializeComponent()` после строки 257 (после создания кнопки).

### Шаг 2.3: Проверка компиляции

1. Нажмите **Build** → **Build Solution** (или **Ctrl+Shift+B**)
2. Убедитесь, что проект компилируется без ошибок
3. Если есть ошибки, проверьте:
   - Правильность синтаксиса метода
   - Наличие всех необходимых using-директив
   - Правильность имен классов и методов

---

## Этап 3: Тестирование

### Шаг 3.1: Подготовка тестового документа Word

1. Откройте **Microsoft Word**
2. Создайте новый документ
3. Введите следующий тестовый текст (скопируйте как есть):

```
# Заголовок 1

## Заголовок 2

Текст параграфа.

- Элемент списка 1
- Элемент списка 2
- Элемент списка 3

```csharp
public class Example 
{ 
    public void Method() { }
}
```

**Второй параграф** с текстом.
```

4. Сохраните документ как `test_markdown.docx`

### Шаг 3.2: Запуск надстройки в режиме отладки

1. В Visual Studio установите **точку останова** (F9) в методе `btnConvertMD_DocNotF_Click` на строке создания сервиса
2. Нажмите **F5** для запуска в режиме отладки
3. Дождитесь открытия Word с загруженной надстройкой
4. Откройте созданный тестовый документ `test_markdown.docx`

### Шаг 3.3: Тестирование базового функционала

1. В Word найдите вкладку **Markdown** на ленте
2. В группе **Преобразование** найдите кнопку **"Word → Markdown (без форматирования)"**
3. Нажмите на кнопку
4. Проверьте результат:
   - В панели Markdown должен отобразиться текст из документа
   - Должно появиться сообщение "Текст из документа Word успешно перенесен в Markdown!"
   - Текст должен быть извлечен "как есть", без преобразования форматирования

**Ожидаемый результат в панели Markdown:**

```markdown
# Заголовок 1

## Заголовок 2

Текст параграфа.

- Элемент списка 1
- Элемент списка 2
- Элемент списка 3

```csharp
public class Example 
{ 
    public void Method() { }
}
```

**Второй параграф** с текстом.
```

### Шаг 3.4: Тестирование нормализации переносов строк

1. Создайте новый тестовый документ Word
2. Введите текст с множественными пустыми строками:

```
# Заголовок



Текст после множественных пустых строк.
```

3. Нажмите кнопку **"Word → Markdown (без форматирования)"**
4. Проверьте результат:
   - Множественные пустые строки (3+) должны быть нормализованы до максимум 2
   - Ожидаемый результат:

```markdown
# Заголовок


Текст после множественных пустых строк.
```

### Шаг 3.5: Тестирование пустого документа

1. Создайте новый пустой документ Word
2. Нажмите кнопку **"Word → Markdown (без форматирования)"**
3. Проверьте результат:
   - Должна отобразиться пустая строка в панели Markdown
   - Должно появиться сообщение об успешном выполнении
   - Приложение не должно падать

### Шаг 3.6: Тестирование обработки ошибок

1. Закройте все документы Word (оставьте Word открытым)
2. Нажмите кнопку **"Word → Markdown (без форматирования)"**
3. Проверьте результат:
   - Должно появиться сообщение об ошибке: "Ошибка при переносе текста: Нет активного документа Word."
   - Приложение не должно падать
   - Панель Markdown не должна изменяться

### Шаг 3.7: Сравнение с существующим функционалом

1. Создайте документ Word с Markdown-текстом (как в шаге 3.1)
2. Нажмите кнопку **"Word → Markdown"** (существующий функционал с форматированием)
3. Запишите результат
4. Нажмите кнопку **"Word → Markdown (без форматирования)"** (новый функционал)
5. Сравните результаты:
   - Результат нового функционала должен содержать исходный Markdown-текст "как есть"
   - Результат существующего функционала может преобразовывать форматирование Word в Markdown

---

## Этап 4: Документирование и финализация

### Шаг 4.1: Добавление XML-комментариев (опционально)

Если XML-комментарии не были добавлены на этапе 1, добавьте их сейчас:

1. Откройте файл `Services/WordToMarkdownPlainTextService.cs`
2. Убедитесь, что все публичные методы и класс имеют XML-комментарии
3. Проверьте, что комментарии соответствуют стандарту проекта

### Шаг 4.2: Проверка стиля кода

1. Убедитесь, что код соответствует стилю проекта:
   - Именование классов и методов в стиле PascalCase
   - Именование приватных полей с префиксом `_`
   - Использование фигурных скобок для всех блоков кода
   - Правильное форматирование и отступы

2. Проверьте, что нет:
   - Неиспользуемых using-директив
   - Неиспользуемых переменных
   - Закомментированного кода (кроме пояснений)

### Шаг 4.3: Финальная проверка компиляции

1. Нажмите **Build** → **Rebuild Solution** (или **Ctrl+Alt+F7**)
2. Убедитесь, что проект компилируется без ошибок и предупреждений
3. Проверьте окно **Error List** (View → Error List) на наличие предупреждений

### Шаг 4.4: Финальное тестирование

1. Запустите надстройку в режиме отладки (F5)
2. Выполните все тесты из **Этапа 3** еще раз
3. Убедитесь, что все тесты проходят успешно

---

## Контрольный список выполнения

### Подготовка
- [ ] Проект открыт в Visual Studio
- [ ] Структура проекта изучена
- [ ] Существующий код изучен для понимания стиля

### Этап 1: Создание сервисного модуля
- [ ] Создан файл `Services/WordToMarkdownPlainTextService.cs`
- [ ] Добавлены необходимые using-директивы
- [ ] Реализован конструктор класса
- [ ] Реализован метод `ExtractPlainText()`
- [ ] Реализован метод `NormalizeLineBreaks()`
- [ ] Реализован метод `NormalizeEmptyLines()`
- [ ] Добавлены XML-комментарии к классу и методам
- [ ] Проект компилируется без ошибок

### Этап 2: Модификация обработчика событий
- [ ] Реализован метод `btnConvertMD_DocNotF_Click` в `MarkdownRibbon.cs`
- [ ] Обработчик события подключен в `MarkdownRibbon.Designer.cs` (проверка)
- [ ] Добавлена обработка ошибок с try-catch
- [ ] Добавлены сообщения пользователю об успехе и ошибке
- [ ] Проект компилируется без ошибок

### Этап 3: Тестирование
- [ ] Создан тестовый документ Word с Markdown-текстом
- [ ] Выполнен тест 1: Базовое извлечение текста
- [ ] Выполнен тест 2: Нормализация множественных пустых строк
- [ ] Выполнен тест 3: Пустой документ
- [ ] Выполнен тест 4: Обработка ошибки (нет активного документа)
- [ ] Выполнено сравнение с существующим функционалом
- [ ] Все тесты проходят успешно

### Этап 4: Документирование и финализация
- [ ] Добавлены XML-комментарии (если необходимо)
- [ ] Проверен стиль кода
- [ ] Проект компилируется без ошибок и предупреждений
- [ ] Выполнено финальное тестирование
- [ ] Все критерии приемки выполнены

---

## Решение типичных проблем

### Проблема 1: Ошибка компиляции "The name 'Globals' does not exist"

**Решение:**
- Убедитесь, что в файле `WordToMarkdownPlainTextService.cs` добавлена using-директива для пространства имен, содержащего `Globals`
- Проверьте, что проект является надстройкой VSTO (Visual Studio Tools for Office)

### Проблема 2: Ошибка "Нет активного документа Word" при наличии открытого документа

**Решение:**
- Убедитесь, что документ действительно активен (фокус находится на окне Word)
- Проверьте, что `_activeDoc` не равен null в конструкторе

### Проблема 3: Текст извлекается с лишними символами (\r, \a)

**Решение:**
- Проверьте метод `NormalizeLineBreaks()` - он должен заменять все варианты переносов строк
- Убедитесь, что метод вызывается перед `NormalizeEmptyLines()`

### Проблема 4: Множественные пустые строки не нормализуются

**Решение:**
- Проверьте метод `NormalizeEmptyLines()` - он должен использовать цикл `while` для обработки всех случаев
- Убедитесь, что метод вызывается после `NormalizeLineBreaks()`

### Проблема 5: Кнопка не реагирует на нажатие

**Решение:**
- Проверьте, что обработчик события подключен в `MarkdownRibbon.Designer.cs` (строка 258)
- Убедитесь, что метод `btnConvertMD_DocNotF_Click` имеет правильную сигнатуру
- Проверьте, что кнопка добавлена в группу `grpConvert` в Designer

---

## Дополнительные замечания

### Производительность

- Метод `ExtractPlainText()` должен работать быстро даже для больших документов (до 100 000 символов)
- Если производительность низкая, проверьте использование `StringBuilder` для конкатенации строк (в текущей реализации не требуется)

### Совместимость

- Функционал должен работать с Microsoft Word 2016 и выше
- Функционал должен работать с Microsoft Word 365
- Новый функционал не должен влиять на существующий функционал (`btnConvert`, `btnConvertMD_Doc`)

### Расширение функционала (опционально)

В будущем можно добавить:
- Опцию сохранения специальных символов (неразрывные пробелы)
- Возможность извлечения текста только из выделенного фрагмента
- Предпросмотр результата перед установкой в панель Markdown
- Настройки для управления нормализацией пустых строк

---

## Заключение

После выполнения всех этапов инструкции функционал переноса текста из Word в Markdown без форматирования должен быть полностью реализован и протестирован.

Если возникнут вопросы или проблемы, обратитесь к:
- Техническому заданию: `docs/plan/Техническое_задание_перенос_Word_в_Markdown_без_форматирования.md`
- Существующему коду: `Services/WordToMarkdownService.cs` (для справки)
- Документации проекта в папке `docs/`

---

**Дата создания инструкции:** 28.12.2025  
**Версия:** 1.0  
**Статус:** Готово к использованию

