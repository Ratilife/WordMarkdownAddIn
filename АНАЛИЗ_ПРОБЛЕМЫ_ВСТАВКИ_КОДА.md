# Анализ проблемы вставки кода в Word

## Проблема
В Word вставляется только фрагмент кода (58 символов) вместо полного кода (352 символа).

## Причина
При установке `codeParagraph.Range.Text = Code` Word автоматически разбивает многострочный текст на несколько параграфов (по переносам строк `\n` или `\r\n`). После этого `codeParagraph.Range` указывает только на **один параграф**, а не на весь код.

## Доказательства из диагностики

### Исходные данные:
- **originalCode**: 352 символа (полный код функции)
  ```
  @staticmethod
  def create_editor_for_type(content_type, parent=None):
      if content_type in ['template', 'folder', 'file']:
          return EditorFactory.create_editor('.st', parent)
      elif content_type == 'markdown':
          return EditorFactory.create_editor('.md', parent)
      else:
          return EditorFactory.create_editor('.txt', parent)
  ```

- **normalizedRange**: 58 символов (только последняя строка)
  ```
          return EditorFactory.create_editor('.txt', parent)
  ```

### Что происходит:
1. Код вставляется через `codeParagraph.Range.Text = Code` (строка 702)
2. Word разбивает код на 7 параграфов (по количеству строк)
3. `codeParagraph` остается ссылкой на **первый** параграф
4. `codeParagraph.Range` охватывает только первый параграф
5. При создании `codeRange = doc.Range(rangeStart, codeRangeEnd)` (строка 714) получается Range только для одного параграфа
6. В результате `codeRange.Text` содержит только часть кода

## Решение

### Вариант 1: Вставить код как один параграф (заменить переносы строк)
```csharp
// Заменяем переносы строк на пробелы или специальные символы
string codeForWord = Code.Replace("\r\n", " ").Replace("\n", " ");
codeParagraph.Range.Text = codeForWord;
```
**Минус**: Код будет в одной строке, потеряется форматирование.

### Вариант 2: Вставить код построчно и собрать Range всех параграфов
```csharp
// Вставляем код построчно
var lines = Code.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None);
var firstParagraph = doc.Content.Paragraphs.Add();
int startPos = firstParagraph.Range.Start;

foreach (var line in lines)
{
    var para = doc.Content.Paragraphs.Add();
    para.Range.Text = line;
}

// Создаем Range, охватывающий все параграфы
int endPos = doc.Content.Paragraphs[doc.Content.Paragraphs.Count].Range.End;
var codeRange = doc.Range(startPos, endPos - 1);
```
**Минус**: Сложнее, нужно отслеживать все параграфы.

### Вариант 3: Использовать InsertAfter и собрать Range (РЕКОМЕНДУЕТСЯ)
```csharp
// Сохраняем начальную позицию
int startPos = doc.Content.End - 1;

// Вставляем код через InsertAfter (сохраняет переносы строк в одном параграфе)
var range = doc.Range(startPos);
range.InsertAfter(Code);

// Создаем Range для всего вставленного кода
int endPos = doc.Content.End - 1;
var codeRange = doc.Range(startPos, endPos);
```
**Плюс**: Проще и надежнее.

### Вариант 4: Использовать специальный символ для переносов строк
```csharp
// Вставляем код с заменой \n на специальный символ, который Word не разобьет
// Но это сложно и может вызвать проблемы с форматированием
```

## Рекомендуемое исправление

Использовать **Вариант 3** с небольшими модификациями:

```csharp
public void ApplyToWord(Document doc)
{
    if (doc == null || string.IsNullOrEmpty(Code))
        return;

    try
    {
        // 1. Сохраняем начальную позицию
        int startPos = doc.Content.End - 1;
        
        // 2. Вставляем код через InsertAfter
        var insertRange = doc.Range(startPos);
        insertRange.InsertAfter(Code);
        
        // 3. Создаем Range для всего вставленного кода
        int endPos = doc.Content.End - 1;
        // Исключаем символ конца параграфа, если он есть
        if (endPos > startPos && doc.Range(endPos - 1, endPos).Text == "\r")
        {
            endPos--;
        }
        var codeRange = doc.Range(startPos, endPos);
        
        // 4. Применяем форматирование к codeRange
        codeRange.Font.Name = "Consolas";
        codeRange.Font.Size = 10;
        codeRange.Shading.BackgroundPatternColor = Word.WdColor.wdColorGray25;
        // ... остальное форматирование
        
        // 5. Применяем подсветку
        SyntaxHighlighter.HighlightCodeBlock(codeRange, Code, normalizedLanguage);
        
        // 6. Добавляем пустой параграф после кода
        doc.Content.Paragraphs.Add();
    }
    catch (Exception ex)
    {
        System.Diagnostics.Debug.WriteLine($"Ошибка при вставке блока кода: {ex.Message}");
    }
}
```

## Проверка после исправления

После применения исправления запустите диагностику снова. Ожидаемый результат:
- `originalCode.Length` == `normalizedRange.Length`
- `Тексты совпадают: True`
- Все токены должны применяться



