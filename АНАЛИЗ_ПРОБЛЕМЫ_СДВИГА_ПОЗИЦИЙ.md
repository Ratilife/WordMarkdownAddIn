# Анализ проблемы сдвига позиций токенов

## Проблема
Подсветка применяется, но **неправильно** - цвета применяются не к тем фрагментам кода. Из диагностики видно, что все токены (кроме первого) имеют несовпадение текста.

## Ключевые наблюдения из диагностики

### 1. Тексты совпадают по длине, но НЕ по содержимому
```
Длина normalizedCode: 345
Длина normalizedRange: 345
Тексты совпадают: True  ← Это обманчиво!
```

**НО** при проверке каждого токена:
- Токен 'def' [15-18]: ожидается 'def', получено 'ef '
- Токен '=' [62-63]: ожидается '=', получено 'N'
- Токен 'None' [63-67]: ожидается 'None', получено 'one)'

### 2. Систематический сдвиг позиций
Все токены (кроме первого) имеют сдвиг на **1-2 символа**. Это указывает на проблему с обработкой переносов строк.

## Корневая причина

### Проблема: Различие в представлении переносов строк

1. **originalCode** (из Markdown):
   - Использует `\n` (LF) для переносов строк
   - Позиции токенов считаются относительно этого текста

2. **normalizedRange** (из Word):
   - Word может использовать `\r\n` (CRLF) для переносов строк
   - При нормализации `\r\n` → `\n`, длина совпадает
   - **НО** позиции символов в Word остаются с учетом `\r\n`

3. **При применении токенов:**
   - Позиции токенов считаются относительно `originalCode` (где `\n` = 1 символ)
   - В Word реальные позиции учитывают `\r\n` (где `\r\n` = 2 символа)
   - Результат: **систематический сдвиг позиций**

### Пример проблемы:

**originalCode:**
```
@staticmethod\n
def create_editor...
```
Позиция 'def' = 15 (после '@staticmethod' + '\n')

**Word Range (после нормализации):**
```
@staticmethod\r\n
def create_editor...
```
Реальная позиция 'def' в Word = 16 (после '@staticmethod' + '\r\n')

**Результат:**
- Токен применяется к позиции [15-18] в originalCode
- В Word это соответствует позиции [15-18], но там находится 'ef ' вместо 'def'
- Правильная позиция в Word должна быть [16-19]

## Детальный анализ несовпадений

### Пример 1: Токен 'def'
- **Ожидается:** 'def' на позиции [15-18]
- **Получено:** 'ef ' на позиции [15-18] в Word
- **Причина:** Сдвиг на 1 символ из-за `\n` vs `\r\n`

### Пример 2: Токен '='
- **Ожидается:** '=' на позиции [62-63]
- **Получено:** 'N' на позиции [62-63] в Word
- **Причина:** Накопительный сдвиг из-за нескольких переносов строк

### Пример 3: Токен 'None'
- **Ожидается:** 'None' на позиции [63-67]
- **Получено:** 'one)' на позиции [63-67] в Word
- **Причина:** Продолжение сдвига

## Почему первый токен работает?

Токен '@staticmethod' на позиции [0-13] работает, потому что:
- Он находится в начале текста
- До него нет переносов строк
- Нет накопленного сдвига

## Решения

### Решение 1: Пересчитать позиции токенов относительно реального текста Word

**Подход:**
1. Получить реальный текст из Word Range (до нормализации)
2. Создать маппинг позиций между originalCode и Word текстом
3. Пересчитать позиции всех токенов с учетом маппинга

**Проблема:** Сложно, требует создания карты соответствия позиций.

### Решение 2: Парсить токены из реального текста Word (РЕКОМЕНДУЕТСЯ)

**Подход:**
1. Получить реальный текст из Word Range
2. Нормализовать его так же, как originalCode
3. **Парсить токены из нормализованного текста Word**, а не из originalCode
4. Применять токены к тем же позициям

**Преимущества:**
- Токены парсятся из того же текста, к которому применяются
- Нет проблем с несовпадением позиций
- Проще в реализации

### Решение 3: Использовать реальный текст Word для парсинга и применения

**Изменения в `ApplyHighlightingToWordRange`:**

```csharp
public static void ApplyHighlightingToWordRange(
    Word.Range range,
    List<Token> tokens,  // ← Убрать этот параметр
    string originalCode)  // ← Убрать этот параметр
{
    // 1. Получить реальный текст из Range
    string rangeText = range.Text;
    string normalizedRangeText = rangeText.TrimEnd('\r', '\n', '\a');
    string normalizedCode = normalizedRangeText.Replace("\r\n", "\n").Replace("\r", "\n");
    
    // 2. ПАРСИТЬ ТОКЕНЫ ИЗ РЕАЛЬНОГО ТЕКСТА WORD
    // (нужно передать language извне)
    List<Token> tokens = ParseCode(normalizedCode, language);
    
    // 3. Применять токены к тем же позициям
    // Теперь позиции точно совпадают!
}
```

## Рекомендуемое исправление

### Изменить сигнатуру `HighlightCodeBlock`:

```csharp
public static void HighlightCodeBlock(Word.Range range, string language = "python")
{
    if (range == null)
        return;

    // 1. Получаем реальный текст из Range
    string rangeText = range.Text;
    string normalizedRangeText = rangeText.TrimEnd('\r', '\n', '\a');
    string normalizedCode = normalizedRangeText.Replace("\r\n", "\n").Replace("\r", "\n");
    
    if (string.IsNullOrEmpty(normalizedCode))
        return;

    // 2. Парсим токены ИЗ РЕАЛЬНОГО ТЕКСТА WORD
    List<Token> tokens = ParseCode(normalizedCode, language);
    
    // 3. Применяем токены к Range
    // Теперь позиции точно совпадают, так как токены парсятся из того же текста
    ApplyHighlightingToWordRange(range, tokens, normalizedCode);
}
```

### Изменить `ApplyHighlightingToWordRange`:

```csharp
public static void ApplyHighlightingToWordRange(
    Word.Range range,
    List<Token> tokens,
    string code)  // ← Теперь это нормализованный текст из Word
{
    // Убрать все проверки на несовпадение текстов
    // Просто применять токены к позициям
    // Позиции токенов теперь точно соответствуют позициям в Range
}
```

### Изменить вызов в `WordCodeBlock.ApplyToWord`:

```csharp
// После вставки кода и создания codeRange
// Передаем только Range и язык, без Code
SyntaxHighlighter.HighlightCodeBlock(codeRange, normalizedLanguage);
```

## Проверка после исправления

После применения исправления ожидаемый результат диагностики:
- Все токены должны иметь `Тексты совпадают: True`
- Подсветка должна применяться к правильным фрагментам кода
- Цвета должны соответствовать типам токенов

## Вывод

**Основная проблема:** Токены парсятся из `originalCode` (с `\n`), но применяются к Word Range (где `\r\n`), что вызывает систематический сдвиг позиций.

**Решение:** Парсить токены из реального текста Word Range, а не из originalCode. Это гарантирует, что позиции токенов точно соответствуют позициям в Word документе.

